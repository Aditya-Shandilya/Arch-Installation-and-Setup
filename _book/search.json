[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Arch Linux Installation and Setup Personal Guide",
    "section": "",
    "text": "1 Welcome\nThis is a personal documentation of my Arch Linux journey, from installation to daily use. Unlike comprehensive guides or tutorials, this book documents what I learn as I learn it.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html",
    "href": "content/minimal_install_intro.html",
    "title": "2  Manual Arch Linux Installation",
    "section": "",
    "text": "2.1 Introduction\nThis chapter documents a manual Arch Linux installation process. Unlike automated installers, this approach requires understanding each component of the system. The goal is to build knowledge incrementally, creating a foundation for deeper Linux expertise.\nThe installation follows the Arch philosophy: simplicity, user control, and transparency. By the end, you’ll have a minimal, command-line system ready for customization.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manual Arch Linux Installation</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#vmware-pre-installation-setup",
    "href": "content/minimal_install_intro.html#vmware-pre-installation-setup",
    "title": "1  Overview",
    "section": "",
    "text": "Table 1.1: Pre-installation configuration steps\n\n\n\n\n\n\n\n\n\n\n\nStep\nAction\nCommand/Setting\nExplanation\n\n\n\n\nVM Configuration\nSet up the virtual machine in VMware.\nDisk: 20 GB, RAM: 4 GB, CPU: 2 Cores\nAllocates resources for a stable desktop environment.\n\n\nFirmware Check\nEnsured the VM was using modern booting.\nVMware Settings: Options → Advanced → Firmware Type: UEFI\nUEFI is the modern successor to BIOS and is required for the EFI System Partition.\n\n\nBoot Mode Check\nVerified the live environment booted in UEFI mode.\nls /sys/firmware/efi/efivars\nConfirmed the presence of the directory, indicating a successful UEFI boot.\n\n\nTime Sync\nSynchronized the system clock.\ntimedatectl set-ntp true\nImportant for secure connections and correct installation logs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#disk-partitioning-and-btrfs-setup",
    "href": "content/minimal_install_intro.html#disk-partitioning-and-btrfs-setup",
    "title": "1  Overview",
    "section": "1.2 2. Disk Partitioning and Btrfs Setup",
    "text": "1.2 2. Disk Partitioning and Btrfs Setup\nThe disk /dev/sda was partitioned using a GPT (GUID Partition Table) structure. The advanced Btrfs file system was chosen for its snapshot and compression capabilities.\n\n1.2.1 A. Partitioning (/dev/sda)\nPartitioning was done using cfdisk /dev/sda.\n\n\n\nTable 1.2: Partition layout for /dev/sda\n\n\n\n\n\n\n\n\n\n\n\n\nDevice\nSize\nType\nFilesystem\nPurpose\n\n\n\n\n/dev/sda1\n512 MiB\nEFI System\nFAT32\nUEFI Boot: Holds the GRUB bootloader files.\n\n\n/dev/sda2\n2 GiB\nLinux Swap\nswap\nVirtual memory area. (2 GiB is adequate for a VM with ≥ 4 GiB RAM).\n\n\n/dev/sda3\nRemaining\nLinux Filesystem\nBtrfs\nMain Data Container: Holds all OS and user data via subvolumes.\n\n\n\n\n\n\n\n\n1.2.2 B. Formatting and Subvolume Creation\n#| eval: false\n#| code-summary: \"Format partitions and create Btrfs subvolumes\"\n\n# Format the partitions\nmkfs.fat -F32 /dev/sda1\nmkswap /dev/sda2; swapon /dev/sda2\nmkfs.btrfs -L ArchRoot /dev/sda3  # Label the main partition\n\n# Mount the raw partition to create subvolumes\nmount /dev/sda3 /mnt\nbtrfs subvolume create /mnt/@      # Subvolume for / (root)\nbtrfs subvolume create /mnt/home   # Subvolume for /home (Note: used 'home', not '@home')\nbtrfs subvolume create /mnt/@pkg   # Subvolume for /var/cache/pacman/pkg\numount /mnt\n\n\n1.2.3 C. Final Mounting and Optimization\nThe subvolumes were mounted with performance and storage optimization flags:\n\n\n\nTable 1.3: Mount commands with optimization flags\n\n\n\n\n\n\n\n\n\nCommand\nExplanation\n\n\n\n\nmount -o compress=zstd,noatime,subvol=@ /dev/sda3 /mnt\nMounts the core OS to /mnt. compress=zstd saves space; noatime improves disk performance.\n\n\nmkdir -p /mnt/{boot/efi,home,var/cache/pacman/pkg}\nCrucial Fix: Creates all required mount point directories inside the new root (/mnt).\n\n\nmount -o compress=zstd,noatime,subvol=home /dev/sda3 /mnt/home\nMounts the user data subvolume. (Used subvol=home to match the created name).\n\n\nmount -o compress=zstd,noatime,subvol=@pkg /dev/sda3 /mnt/var/cache/pacman/pkg\nMounts the package cache subvolume.\n\n\nmount /dev/sda1 /mnt/boot/efi\nMounts the EFI partition.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#installation-of-base-system",
    "href": "content/minimal_install_intro.html#installation-of-base-system",
    "title": "1  Overview",
    "section": "1.3 3. Installation of Base System",
    "text": "1.3 3. Installation of Base System\n\n\n\nTable 1.4: Base system installation steps\n\n\n\n\n\n\n\n\n\n\n\nStep\nAction\nCommand/Setting\nExplanation\n\n\n\n\nMirrorlist\nPrioritized nearest German mirrors in /etc/pacman.d/mirrorlist.\nMoved de.arch.niran.jan.co, arch.phinau.de, etc., to the top.\nEnsures rapid download speeds for the installation.\n\n\nBase Install\nInstalled the core system packages.\npacstrap /mnt base linux linux-firmware vim\nInstalls the kernel, system utilities, and the vim text editor.\n\n\nFstab Generation\nCreated the file system table.\ngenfstab -U /mnt &gt;&gt; /mnt/etc/fstab\nUses UUIDs (Universally Unique Identifiers) for stable mounting of all partitions/subvolumes on boot.\n\n\nChroot\nSwitched the terminal context to the new system.\narch-chroot /mnt\nAllows configuration of the installed system as if it were already booted.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#system-configuration",
    "href": "content/minimal_install_intro.html#system-configuration",
    "title": "2  Manual Arch Linux Installation",
    "section": "2.5 System Configuration",
    "text": "2.5 System Configuration\n\n2.5.1 Enter the New System\narch-chroot /mnt\nWhat this does: Changes root into the new installation. This means you’re now operating within the newly installed system rather than the live environment.\nWhy chroot: This allows you to configure the system as if you had booted into it. All commands now affect the installed system, not the live USB.\n\n\n2.5.2 Set Time Zone\nln -sf /usr/share/zoneinfo/Region/City /etc/localtime\nhwclock --systohc\nWhat this does:\n\nCreates a symbolic link from your timezone file to /etc/localtime\nGenerates /etc/adjtime based on the current system time\n\nExample: For New York: ln -sf /usr/share/zoneinfo/America/New_York /etc/localtime\nWhy this matters: The timezone setting affects timestamps in logs, scheduled tasks, and user-facing time displays.\n\n\n2.5.3 Configure Localization\nLocales define language, character encoding, and regional formatting.\nvim /etc/locale.gen\nWhat to do: Uncomment your locale(s). Most users will uncomment en_US.UTF-8 UTF-8.\nUnderstanding UTF-8: UTF-8 is a character encoding that supports international characters. It’s the standard for modern Linux systems.\nlocale-gen\necho \"LANG=en_US.UTF-8\" &gt; /etc/locale.conf\nWhat this does:\n\nGenerates the locale files you uncommented\nSets the system-wide default locale\n\n\n\n2.5.4 Configure Networking\necho \"your-hostname\" &gt; /etc/hostname\nWhat this does: Sets your computer’s name on the network. Choose something memorable and unique.\npacman -S networkmanager\nsystemctl enable NetworkManager\nWhat this does:\n\nInstalls NetworkManager, a program that handles network connections\nEnables the service to start automatically at boot\n\nWhy NetworkManager: It provides automatic network configuration, WiFi management, and connection profiles. Essential for laptops and systems with multiple networks.\n\n\n2.5.5 Set Root Password\npasswd\nWhat this does: Sets the password for the root (administrator) account.\nSecurity note: Choose a strong password. Root access allows complete system control.\n\n\n2.5.6 Create User Account\nuseradd -mG wheel -s /bin/bash yourusername\npasswd yourusername\nWhat this does:\n\nCreates a new user with:\n\n-m: Creates a home directory\n-G wheel: Adds user to the wheel group (for sudo privileges)\n-s /bin/bash: Sets Bash as the default shell\n\nSets the user’s password\n\nWhy not use root: Running as root constantly is dangerous. A regular user account with sudo provides security while maintaining administrative capabilities.\n\n\n2.5.7 Configure sudo\npacman -S sudo\nvisudo\nWhat this does:\n\nInstalls sudo (allows users to run commands as root)\nOpens the sudoers configuration file safely\n\nIn visudo: Uncomment the line: %wheel ALL=(ALL) ALL\nWhat this means: Any user in the wheel group can run any command as any user by prefixing with sudo.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manual Arch Linux Installation</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#conclusion",
    "href": "content/minimal_install_intro.html#conclusion",
    "title": "1  Overview",
    "section": "1.5 Conclusion",
    "text": "1.5 Conclusion\nThis minimal Arch Linux installation provides a solid foundation for building a custom desktop environment. The use of Btrfs subvolumes allows for flexible system management and easy snapshots, while the optimized mount options ensure good performance.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#next-steps",
    "href": "content/minimal_install_intro.html#next-steps",
    "title": "2  Manual Arch Linux Installation",
    "section": "2.9 Next Steps",
    "text": "2.9 Next Steps\nTo create a usable desktop environment, you’ll need to install:\n\nDisplay Server (xorg-server): Manages graphics output\nWindow Manager (e.g., i3, dwm): Controls window placement and behavior\nTerminal Emulator (e.g., alacritty): Provides terminal access in the GUI\nDisplay Manager (e.g., lightdm): Provides graphical login\n\nThese will be covered in subsequent chapters as you continue building your customized system.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manual Arch Linux Installation</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#phase-1-pre-installation-checks",
    "href": "content/minimal_install_intro.html#phase-1-pre-installation-checks",
    "title": "1  Introduction",
    "section": "1.1 Phase 1: Pre-Installation Checks",
    "text": "1.1 Phase 1: Pre-Installation Checks\n\n1.1.1 Understanding the Live Environment\nWhen you boot the Arch Linux ISO, you’re running a complete, temporary Linux system in RAM. This “live environment” provides all the tools needed to install Arch on your disk. Nothing you do here persists after reboot—it’s a clean slate every time.\n\n\n1.1.2 Step 1.1: Verify Boot Mode (UEFI vs BIOS)\nModern systems use UEFI (Unified Extensible Firmware Interface), which replaced the legacy BIOS. Verifying your boot mode is critical because the bootloader installation differs significantly between the two.\n#| eval: false\nls /sys/firmware/efi/efivars\nWhat this does:\n\nLists the contents of the efivars directory\nThis directory only exists when booted in UEFI mode\nThe directory contains firmware variables that the OS can read/write\n\nExpected output:\nIf you see a list of files (with names like Boot0000-..., BootCurrent-...), you’re in UEFI mode. This is what we want.\nIf the directory doesn’t exist:\nYou’ve booted in legacy BIOS mode. You’ll need to:\n\nShut down the VM\nGo to VMware settings → Options → Advanced\nChange “Firmware type” to “UEFI”\nRestart with the Arch ISO\n\nWhy UEFI matters:\n\nUEFI requires a special FAT32 partition (ESP - EFI System Partition)\nUEFI uses .efi bootloader files instead of installing to the MBR\nUEFI provides better security features (Secure Boot support)\nUEFI is mandatory for disks larger than 2TB with GPT\n\n\n\n1.1.3 Step 1.2: Verify Network Connectivity\nThe Arch installation requires downloading packages from internet repositories. The live environment typically configures network automatically via DHCP.\n#| eval: false\nping archlinux.org\nWhat this does:\n\nSends ICMP echo requests to archlinux.org\nTests both DNS resolution and internet connectivity\nContinues indefinitely until you stop it\n\nExpected output:\n64 bytes from archlinux.org (95.217.163.246): icmp_seq=1 ttl=54 time=12.3 ms\n64 bytes from archlinux.org (95.217.163.246): icmp_seq=2 ttl=54 time=11.8 ms\nPress Ctrl+C to stop after confirming connectivity.\nIf ping fails:\nFor VMware, network should work automatically. If not:\n\nCheck VMware network adapter settings (should be NAT or Bridged)\nVerify the VM has a network adapter attached\nTry ip link to see network interfaces\nFor Wi-Fi (on physical machines), use iwctl to connect\n\nUnderstanding the output:\n\n64 bytes: Size of the reply packet\nicmp_seq: Sequence number (increments with each ping)\nttl=54: Time To Live (hops remaining before packet is discarded)\ntime=12.3 ms: Round-trip latency\n\n\n\n1.1.4 Step 1.3: Update System Clock\nAccurate system time is crucial for several reasons: SSL/TLS certificate validation, file timestamps, and system logs.\n#| eval: false\ntimedatectl set-ntp true\nWhat this does:\n\nEnables Network Time Protocol (NTP) synchronization\nThe system will automatically sync time with internet time servers\nUses systemd-timesyncd service in the background\n\nVerify synchronization:\n#| eval: false\ntimedatectl status\nLook for System clock synchronized: yes and NTP service: active.\nWhy this matters:\n\nPackage installation: Repository mirrors use timestamps; incorrect time can cause validation failures\nSSL/TLS: HTTPS connections fail if your clock is off by more than a few minutes\nLogging: Installation logs need accurate timestamps for troubleshooting",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#phase-2-disk-partitioning-and-file-system-setup",
    "href": "content/minimal_install_intro.html#phase-2-disk-partitioning-and-file-system-setup",
    "title": "1  Introduction",
    "section": "1.2 Phase 2: Disk Partitioning and File System Setup",
    "text": "1.2 Phase 2: Disk Partitioning and File System Setup\n\n1.2.1 Understanding Disk Layout\nBefore partitioning, it’s essential to understand what we’re creating:\n\nEFI System Partition (ESP): Stores bootloader files (.efi binaries)\nSwap Partition: Virtual memory extension (for hibernation and memory overflow)\nRoot Partition: Contains the entire Linux file system\n\n\n\n1.2.2 Why Btrfs?\nWe’re using Btrfs (B-tree File System) instead of ext4 because it offers:\n\nSubvolumes: Logical divisions within a partition that can be mounted independently\nSnapshots: Instant, space-efficient backups of subvolumes\nCompression: Transparent, on-the-fly data compression (saves disk space)\nCopy-on-Write (CoW): Data integrity and efficient copying\n\nSubvolume strategy:\n\n@: Root file system (/)\n@home: User data (/home)\n@pkg: Package cache (/var/cache/pacman/pkg)\n\nThis separation allows you to snapshot the root system without including user data or take separate home directory snapshots.\n\n\n1.2.3 Step 2.1: Partition the Disk\nWe’ll use cfdisk, which provides a user-friendly text interface compared to fdisk.\n#| eval: false\ncfdisk /dev/sda\nWhat this does:\n\nLaunches the curses-based disk partitioning utility\n/dev/sda is typically the first SATA/SCSI disk in the system\nIn VMware, your virtual disk appears as /dev/sda\n\nVerify your disk:\nBefore running cfdisk, check available disks:\n#| eval: false\nlsblk\nYou should see something like:\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0   20G  0 disk \nsr0     11:0    1  800M  0 rom  /run/archiso/bootmnt\nsda is your target disk (20GB as configured), sr0 is the Arch ISO.\nPartitioning workflow:\n\nSelect partition table type: Choose gpt\n\nGPT (GUID Partition Table) is the modern standard\nSupports disks &gt;2TB\nRequired for UEFI boot\nStores partition data redundantly (more reliable)\n\nCreate EFI partition (512 MiB):\n\nNavigate to free space\nSelect [ New ]\nEnter size: 512M\nSelect [ Type ] → Choose EFI System\n\nWhy 512 MiB?\n\nUEFI spec recommends 100-550 MiB\n512 MiB provides room for multiple bootloaders (dual-boot scenarios)\nLarger size accommodates kernel backups in /boot\n\nCreate Swap partition (2 GiB):\n\nSelect remaining free space\nSelect [ New ]\nEnter size: 2G\nSelect [ Type ] → Choose Linux swap\n\nSwap size guidelines:\n\nFor hibernation: swap ≥ RAM size\nFor 4GB RAM without hibernation: 2GB is adequate\nModern systems with ample RAM need less swap\nFormula: swap = √RAM (rounded up) for systems with &gt;2GB RAM\n\nCreate Root partition (remaining space):\n\nSelect remaining free space\nSelect [ New ]\nPress Enter (accepts all remaining space)\nType should default to Linux filesystem (correct for Btrfs)\n\nWrite changes:\n\nSelect [ Write ]\nType yes (lowercase, exactly)\nSelect [ Quit ]\n\n\nImportant notes:\n\nChanges aren’t saved until you write them\nDouble-check partition sizes before writing\ncfdisk automatically sector-aligns partitions for optimal performance\n\nVerify partitions:\n#| eval: false\nlsblk\nShould now show:\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0   20G  0 disk \n├─sda1   8:1    0  512M  0 part \n├─sda2   8:2    0    2G  0 part \n└─sda3   8:3    0 17.5G  0 part \n\n\n1.2.4 Step 2.2: Format the Partitions\nFormatting creates a file system structure on the raw partition. This defines how data is stored and retrieved.\n\n1.2.4.1 Format EFI Partition\n#| eval: false\nmkfs.fat -F32 /dev/sda1\nWhat this does:\n\nmkfs.fat: Creates a FAT file system\n-F32: Specifies FAT32 (required by UEFI spec)\n/dev/sda1: The EFI partition we created\n\nWhy FAT32?\n\nUEFI firmware can only read FAT12/FAT16/FAT32\nFAT32 supports files up to 4GB (adequate for bootloaders)\nSimple, universally compatible file system\nNo journaling (unnecessary for read-mostly bootloader files)\n\nExpected output:\nmkfs.fat 4.2 (2021-01-31)\n\n\n1.2.4.2 Format and Activate Swap\n#| eval: false\nmkswap /dev/sda2\nswapon /dev/sda2\nWhat this does:\n\nmkswap: Writes swap signature and prepares the partition\nswapon: Activates the swap partition immediately\n\nUnderstanding swap:\nSwap is a dedicated area on disk used as virtual memory. The kernel moves inactive memory pages to swap when RAM is full.\nVerify swap:\n#| eval: false\nfree -h\nYou should see your swap space listed:\n              total        used        free      shared  buff/cache   available\nMem:          3.9Gi       200Mi       3.5Gi        10Mi       200Mi       3.6Gi\nSwap:         2.0Gi          0B       2.0Gi\nWhen is swap used?\n\nRAM is exhausted (prevents OOM killer)\nHibernation (RAM contents saved to swap)\nKernel moves rarely-used pages to swap proactively\n\n\n\n1.2.4.3 Format Root Partition with Btrfs\n#| eval: false\nmkfs.btrfs -L ArchRoot /dev/sda3\nWhat this does:\n\nmkfs.btrfs: Creates a Btrfs file system\n-L ArchRoot: Sets the file system label to “ArchRoot”\n/dev/sda3: The root partition\n\nFile system label benefits:\n\nHuman-readable identification\nCan mount by label: mount LABEL=ArchRoot /mnt\nPersists across partition renumbering\nVisible in lsblk -f output\n\nExpected output:\nbtrfs-progs v6.x.x\nSee http://btrfs.wiki.kernel.org for more information.\n\nLabel:              ArchRoot\nUUID:               [long UUID string]\nNode size:          16384\nSector size:        4096\nFilesystem size:    17.50GiB\n...\nBtrfs default features:\n\nCopy-on-Write (CoW): Original data never overwritten\nChecksumming: All data and metadata checksummed for integrity\nMulti-device support: Can span multiple disks (we’re using one)\n\n\n\n\n1.2.5 Step 2.3: Create Btrfs Subvolumes\nSubvolumes are the key feature that makes Btrfs powerful for system management.\n\n1.2.5.1 Initial Mount\n#| eval: false\nmount /dev/sda3 /mnt\nWhat this does:\n\nMounts the Btrfs partition to /mnt\nThis is a temporary mount to create subvolumes\nWe’re mounting the “root” of the Btrfs filesystem, not a subvolume yet\n\n\n\n1.2.5.2 Create Subvolumes\n#| eval: false\nbtrfs subvolume create /mnt/@\nbtrfs subvolume create /mnt/@home\nbtrfs subvolume create /mnt/@pkg\nWhat this does:\nEach command creates a new subvolume within the Btrfs filesystem.\nSubvolume naming conventions:\n\n@ prefix is a convention from Ubuntu/Timeshift (not mandatory)\n@: Root subvolume (will be mounted at /)\n@home: Home directories subvolume (will be mounted at /home)\n@pkg: Package cache subvolume (will be mounted at /var/cache/pacman/pkg)\n\nWhy these specific subvolumes?\n\n@ (root):\n\nContains the OS: /bin, /etc, /usr, etc.\nSnapshot before system updates for easy rollback\nCan restore without affecting user data\n\n@home:\n\nContains user data: documents, configs, downloads\nSnapshot independently of system\nExclude from system snapshots (saves space)\nPreserve user data when reinstalling OS\n\n@pkg:\n\nContains downloaded packages (/var/cache/pacman/pkg)\nPackages can be large (multi-GB cache)\nExclude from snapshots (packages can be re-downloaded)\nShare across snapshots (avoid duplicating package cache)\n\n\nVerify subvolumes:\n#| eval: false\nbtrfs subvolume list /mnt\nExpected output:\nID 256 gen 8 top level 5 path @\nID 257 gen 8 top level 5 path @home\nID 258 gen 8 top level 5 path @pkg\nUnderstanding the output:\n\nID: Unique identifier for the subvolume\ngen: Generation (changes with each modification)\ntop level 5: Parent subvolume (5 is the root container)\npath: Subvolume path relative to Btrfs root\n\n\n\n1.2.5.3 Unmount for Proper Remounting\n#| eval: false\numount /mnt\nWhy unmount?\nWe mounted the Btrfs root to create subvolumes. Now we need to mount the individual subvolumes with specific options. The Btrfs root itself isn’t meant to be used directly.\n\n\n\n1.2.6 Step 2.4: Mount Subvolumes with Options\nNow we’ll mount each subvolume to its proper location with optimization flags.\n\n1.2.6.1 Mount Root Subvolume\n#| eval: false\nmount -o compress=zstd,noatime,subvol=@ /dev/sda3 /mnt\nBreaking down the options:\n-o: Specifies mount options (comma-separated list)\ncompress=zstd: - Enables transparent compression using Zstandard algorithm - Data is compressed on write, decompressed on read - Happens automatically, applications don’t notice - Benefits: - Reduces disk space usage (typically 30-50% savings) - Can improve read/write speeds (less data to transfer) - Zstd offers excellent compression ratio and speed - Alternatives: compress=lzo (faster, lower ratio), compress=zlib (slower, higher ratio)\nnoatime: - Disables access time updates - Normally, Linux updates a file’s “last access time” on every read - Benefits: - Reduces write operations (improves SSD lifespan) - Improves performance (fewer metadata updates) - Most applications don’t need atime - Alternative: relatime (updates atime only if older than mtime, default in many distros)\nsubvol=@: - Specifies which subvolume to mount - Mount the @ subvolume (our root filesystem) - Without this, you’d mount the Btrfs root container\n/dev/sda3: The device containing the Btrfs filesystem\n/mnt: Mount point (where the filesystem appears)\n\n\n1.2.6.2 Create Mount Point Directories\n#| eval: false\nmkdir -p /mnt/{boot/efi,home,var/cache/pacman/pkg}\nWhat this does:\n\nmkdir -p: Creates directories, including parents (no error if exists)\nCreates the directory structure in one command using brace expansion\nExpands to:\n\n  mkdir -p /mnt/boot/efi\n  mkdir -p /mnt/home\n  mkdir -p /mnt/var/cache/pacman/pkg\nWhy this is crucial:\n\nMount points must exist before mounting\nForgetting this is a common installation error\nWithout these directories, subsequent mounts will fail\nThe /boot/efi structure (nested) needs -p to create parents\n\n\n\n1.2.6.3 Mount Home Subvolume\n#| eval: false\nmount -o compress=zstd,noatime,subvol=@home /dev/sda3 /mnt/home\nWhat this does:\n\nMounts the @home subvolume to /mnt/home\nUses the same optimization options as root\nUser data will be stored here: /home/username/\n\nNote on subvolume naming:\nIf you created the subvolume as @home, use subvol=@home. In the original document, the subvolume was actually created as home (without @), so the mount command used subvol=home. Make sure your mount option matches your actual subvolume name.\nTo check:\n#| eval: false\nbtrfs subvolume list /dev/sda3\n\n\n1.2.6.4 Mount Package Cache Subvolume\n#| eval: false\nmount -o compress=zstd,noatime,subvol=@pkg /dev/sda3 /mnt/var/cache/pacman/pkg\nWhat this does:\n\nMounts @pkg subvolume to the pacman cache directory\nSeparates package downloads from system and user data\n\nWhy separate the package cache?\n\nSnapshots: Exclude large package files from system snapshots\nCleanup: Can delete the entire subvolume without affecting the system\nSpace: Package cache can grow to several GB over time\nSharing: Multiple snapshots can share one package cache\n\nAbout pacman cache:\n\nPacman stores downloaded packages here before installation\nAllows downgrading or reinstalling without redownloading\nCan be cleared with pacman -Sc (remove uninstalled packages)\nOr pacman -Scc (remove all cached packages)\n\n\n\n1.2.6.5 Mount EFI Partition\n#| eval: false\nmount /dev/sda1 /mnt/boot/efi\nWhat this does:\n\nMounts the FAT32 EFI partition to /mnt/boot/efi\nNo special options needed (FAT32 doesn’t support them anyway)\nThis is where GRUB will install its .efi files\n\nAlternative mount points:\n\nSome guides use /mnt/boot directly\nWe use /mnt/boot/efi (a subdirectory)\nThis allows /boot itself to be on Btrfs\nKeeps kernel images in the snapshot-able root subvolume\n\n\n\n1.2.6.6 Verify the Complete Mount Structure\n#| eval: false\nlsblk\nExpected output:\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0   20G  0 disk \n├─sda1   8:1    0  512M  0 part /mnt/boot/efi\n├─sda2   8:2    0    2G  0 part [SWAP]\n└─sda3   8:3    0 17.5G  0 part /mnt\n                                 /mnt/home\n                                 /mnt/var/cache/pacman/pkg\nWhat to verify:\n\n/dev/sda1 mounted at /mnt/boot/efi\n/dev/sda2 marked as [SWAP]\n/dev/sda3 mounted three times (three subvolumes)\n\nDetailed mount information:\n#| eval: false\nmount | grep /mnt\nShould show:\n/dev/sda3 on /mnt type btrfs (rw,noatime,compress=zstd:3,space_cache,subvol=/@)\n/dev/sda3 on /mnt/home type btrfs (rw,noatime,compress=zstd:3,space_cache,subvol=/@home)\n/dev/sda3 on /mnt/var/cache/pacman/pkg type btrfs (rw,noatime,compress=zstd:3,space_cache,subvol=/@pkg)\n/dev/sda1 on /mnt/boot/efi type vfat (rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#phase-3-installing-the-base-system",
    "href": "content/minimal_install_intro.html#phase-3-installing-the-base-system",
    "title": "1  Introduction",
    "section": "1.3 Phase 3: Installing the Base System",
    "text": "1.3 Phase 3: Installing the Base System\n\n1.3.1 Understanding Package Mirrors\nArch Linux packages are distributed via mirrors worldwide. Faster mirrors mean faster installation and updates.\n\n1.3.1.1 Step 3.1: Select Mirrors (Optional but Recommended)\n#| eval: false\nvim /etc/pacman.d/mirrorlist\nWhat this file contains:\nA long list of mirror URLs, formatted like:\n## Germany\n#Server = https://arch.mirror.konstant.no/$repo/os/$arch\nServer = https://ftp.fau.de/archlinux/$repo/os/$arch\n#Server = https://mirror.f4st.host/archlinux/$repo/os/$arch\nUnderstanding the format:\n\nLines starting with # are comments (disabled)\nServer = lines are active mirrors\n$repo: Replaced with repository name (core, extra, community)\n$arch: Replaced with architecture (x86_64)\n\nHow to optimize:\n\nFind mirrors in your country (look for ## Germany or your region)\nMove fast mirrors to the top (pacman tries mirrors in order)\nUncomment (# remove) fast mirrors if needed\nLeave at least 5-6 mirrors (redundancy if one is down)\n\nvim quick reference for this task:\n\n/Germany - Search for “Germany”\ndd - Delete (cut) current line\ngg - Go to top of file\np - Paste below current line\n:wq - Write and quit\n\nAlternative method (automatic):\n#| eval: false\nreflector --country Germany --age 12 --protocol https --sort rate --save /etc/pacman.d/mirrorlist\nThis requires reflector package (available in live environment).\n\n\n\n1.3.2 Step 3.2: Install Base Packages\nThis is the core installation step that creates your Arch Linux system.\n#| eval: false\npacstrap /mnt base linux linux-firmware vim\nWhat this does:\n\npacstrap: Arch installation script that sets up base system\n/mnt: Target directory (our mounted root filesystem)\nPackage list: base linux linux-firmware vim\n\nBreaking down each package:\nbase: - Meta-package containing essential system utilities - Includes: bash, coreutils, systemd, glibc - Provides: basic commands (ls, cp, mkdir), init system, C library - This is the minimal foundation of an Arch system\nlinux: - The Linux kernel package - Contains: kernel binary, modules (drivers) - Alternatives: linux-lts (Long Term Support), linux-zen (optimized), linux-hardened - The kernel is the core of the operating system\nlinux-firmware: - Binary firmware blobs for hardware - Contains: Wi-Fi firmware, GPU firmware, etc. - Required for most hardware to function - Can be omitted in VMs (no real hardware), but small size makes it harmless\nvim: - Text editor (Vi IMproved) - Needed for editing configuration files post-installation - Alternatives: nano (easier for beginners), emacs, neovim\nWhat happens during installation:\n\nDownloads packages from mirrors (~400MB total)\nExtracts packages to /mnt\nConfigures basic system structure\nSets up pacman (package manager) database\n\nTime estimate: 5-15 minutes depending on mirror speed\nCommon issues:\n\n“failed to retrieve”: Mirror is down, pacman tries next mirror\n“insufficient disk space”: Check partition sizes with df -h /mnt\n“signature is unknown trust”: System time is wrong, run timedatectl set-ntp true\n\n\n\n1.3.3 Step 3.3: Generate fstab\nThe fstab (file systems table) file tells the system what to mount at boot.\n#| eval: false\ngenfstab -U /mnt &gt;&gt; /mnt/etc/fstab\nWhat this does:\n\ngenfstab: Generates fstab entries from currently mounted filesystems\n-U: Use UUIDs instead of device names\n/mnt: Scan this mount point and its children\n&gt;&gt;: Append output to the file (don’t overwrite)\n\nWhy UUIDs?\nDevice names (/dev/sda1) can change: - Adding/removing disks - Different boot order - Hotplugging USB devices\nUUIDs are permanent: - Universally Unique Identifier - Assigned when filesystem is formatted - Never changes (unless you reformat) - Example: UUID=a1b2c3d4-e5f6-7890-abcd-ef1234567890\nVerify the generated fstab:\n#| eval: false\ncat /mnt/etc/fstab\nExpected content:\n# /dev/sda3 LABEL=ArchRoot\nUUID=&lt;uuid&gt;  /  btrfs  rw,noatime,compress=zstd:3,space_cache,subvol=/@  0 0\n\n# /dev/sda3 LABEL=ArchRoot\nUUID=&lt;uuid&gt;  /home  btrfs  rw,noatime,compress=zstd:3,space_cache,subvol=/@home  0 0\n\n# /dev/sda3 LABEL=ArchRoot\nUUID=&lt;uuid&gt;  /var/cache/pacman/pkg  btrfs  rw,noatime,compress=zstd:3,space_cache,subvol=/@pkg  0 0\n\n# /dev/sda1\nUUID=&lt;uuid&gt;  /boot/efi  vfat  rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro  0 2\n\n# /dev/sda2\nUUID=&lt;uuid&gt;  none  swap  defaults  0 0\nUnderstanding fstab columns:\n\nDevice: UUID or device path\nMount point: Where to mount\nType: Filesystem type (btrfs, vfat, swap)\nOptions: Mount options (same as -o in mount command)\nDump: Backup frequency (0 = never, used by dump tool)\nPass: fsck order (0 = skip, 1 = root first, 2 = others)\n\nImportant notes:\n\nBtrfs subvolumes all have the same UUID (same physical partition)\nThey’re differentiated by subvol= option\nSwap has none as mount point (not mounted, just activated)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#phase-4-configure-the-new-system",
    "href": "content/minimal_install_intro.html#phase-4-configure-the-new-system",
    "title": "1  Introduction",
    "section": "1.4 Phase 4: Configure the New System",
    "text": "1.4 Phase 4: Configure the New System\n\n1.4.1 Understanding chroot\nChroot (change root) allows you to work inside the new system before booting it.\n#| eval: false\narch-chroot /mnt\nWhat this does:\n\nChanges the apparent root directory to /mnt\nInside chroot, / is actually /mnt from the outside\nYou’re now “inside” the installed system\nYour prompt should change to [root@archiso /]#\n\nWhy use chroot:\n\nConfigure system files in their final locations\nInstall additional packages using the new system’s pacman\nSet up users, hostname, bootloader\nTest the environment before rebooting\n\nWhat chroot does NOT do:\n\nDoesn’t boot the kernel (still running live environment kernel)\nDoesn’t start systemd services\nNetwork is shared with live environment\nSome operations (kernel modules) affect live environment\n\nNote: All subsequent commands in Phase 4 run inside the chroot.\n\n\n1.4.2 Step 4.1: Configure Time Zone\nTime zone configuration determines how your system displays time.\n#| eval: false\nln -sf /usr/share/zoneinfo/Europe/Berlin /etc/localtime\nWhat this does:\n\nln -sf: Creates a symbolic link, force overwrite if exists\nSource: /usr/share/zoneinfo/Europe/Berlin (time zone data file)\nTarget: /etc/localtime (system time zone configuration)\n\nFinding your time zone:\n#| eval: false\nls /usr/share/zoneinfo/\nBrowse continents, then:\n#| eval: false\nls /usr/share/zoneinfo/Europe/\nCommon zones:\n\nEurope/Berlin - Germany, most of Western Europe\nAmerica/New_York - US Eastern Time\nAmerica/Los_Angeles - US Pacific Time\nAsia/Tokyo - Japan\nUTC - Coordinated Universal Time (no daylight saving)\n\nSync hardware clock:\n#| eval: false\nhwclock --systohc\nWhat this does:\n\n--systohc: Set hardware clock from system time\nHardware clock: Battery-powered clock in motherboard\nSystem clock: Software clock maintained by kernel\nThis writes current system time to CMOS/UEFI variables\n\nWhy this matters:\n\nHardware clock persists across reboots\nOn boot, system clock initializes from hardware clock\nKeeps time accurate even when system is off\nAssumes hardware clock is in UTC (modern standard)\n\n\n\n1.4.3 Step 4.2: Localization (Generate Locales)\nLocales determine language, character encoding, date/time formats, currency, etc.\n\n1.4.3.1 Edit locale.gen\n#| eval: false\nvim /etc/locale.gen\nWhat this file contains:\nA list of all possible locales, all commented out (disabled): #de_DE.UTF-8 UTF-8 #de_DE ISO-8859-1 #de_DE@euro ISO-8859-15 #en_US.UTF-8 UTF-8 #en_US ISO-8859-1\nWhat to do:\nUncomment (remove #) from the locales you need.\nRecommended: Always uncomment en_US.UTF-8 UTF-8 for:\n\nMost software assumes US English is available\nError messages and documentation are typically in English\nMany programs default to this locale\n\nAdditionally uncomment your native locale if different:\n\nde_DE.UTF-8 UTF-8 for German\nfr_FR.UTF-8 UTF-8 for French\nes_ES.UTF-8 UTF-8 for Spanish\nja_JP.UTF-8 UTF-8 for Japanese\n\nUnderstanding locale format:\n\nen_US: Language code (en) + Country code (US)\nUTF-8: Character encoding (supports all Unicode characters)\nAlternative encodings like ISO-8859-1 are legacy (avoid unless needed)\n\nWhy UTF-8?\n\nSupports all languages and special characters\nModern standard for text encoding\nCompatible with ASCII (first 128 characters identical)\nRequired for proper display of international text\n\nvim quick reference:\n\n/en_US.UTF-8 - Search for the locale\n0 - Move to beginning of line\nx - Delete the # character\n:wq - Write and quit\n\n\n\n1.4.3.2 Generate the Locales\n#| eval: false\nlocale-gen\nWhat this does:\n\nReads /etc/locale.gen\nCompiles all uncommented locales\nCreates binary locale data in /usr/lib/locale/\nGenerates locale archive for fast loading\n\nExpected output:\nGenerating locales...\n  en_US.UTF-8... done\n  de_DE.UTF-8... done\nGeneration complete.\nWhat locales affect:\n\nLanguage of system messages\nDate/time format (MM/DD/YYYY vs DD.MM.YYYY)\nNumber format (1,234.56 vs 1.234,56)\nCurrency symbols ($ vs €)\nPaper size (Letter vs A4)\nSorting order (collation)\n\n\n\n1.4.3.3 Set System Locale\n#| eval: false\necho \"LANG=en_US.UTF-8\" &gt; /etc/locale.conf\nWhat this does:\n\nCreates /etc/locale.conf with the system default locale\nLANG variable sets the fallback for all locale categories\nThis affects system messages, date formats, etc.\n\nWhy en_US.UTF-8 even if you’re not in the US?\n\nError messages: Most documentation and forum help is in English\nTroubleshooting: Easier to search for English error messages\nConsistency: Many programs expect English locale\nCompatibility: Some software has poor translations\n\nAlternative approach (use native language):\n#| eval: false\necho \"LANG=de_DE.UTF-8\" &gt; /etc/locale.conf\nThis makes German the system language.\nAdvanced: Per-category settings:\nYou can mix languages for different aspects:\nLANG=en_US.UTF-8\nLC_TIME=de_DE.UTF-8\nLC_MONETARY=de_DE.UTF-8\nThis gives English messages but German date/currency formats.\nVerify locale settings:\n#| eval: false\nlocale\nShows all locale categories and their current values.\n\n\n\n1.4.4 Step 4.3: Keyboard Layout (Console)\nThis sets the keyboard layout for the virtual console (TTY), not the X server.\n#| eval: false\necho \"KEYMAP=de-latin1\" &gt; /etc/vconsole.conf\nWhat this does:\n\nCreates /etc/vconsole.conf\nSets KEYMAP to de-latin1 (German QWERTZ)\nApplied at boot before any graphical environment\n\nWhy this is needed:\n\nLive environment uses US QWERTY by default\nWithout this, you’ll have wrong layout after reboot\nEspecially important for entering passwords at boot\n\nCommon keymaps:\n\nus - US QWERTY (default)\nde-latin1 or de - German QWERTZ\nuk - UK QWERTY\nfr-latin1 - French AZERTY\nes - Spanish\n\nFinding available keymaps:\n#| eval: false\nlocalectl list-keymaps | grep de\nShows all German keyboard variants:\nde\nde-latin1\nde-latin1-nodeadkeys\nde_CH-latin1\nde_alt_UTF-8\nDifferences:\n\nde-latin1: Standard German with dead keys (for umlauts: ä, ö, ü)\nde-latin1-nodeadkeys: No dead keys (direct character input)\nde_CH-latin1: Swiss German\n\nNote about graphical environments:\nThis only affects the console (Ctrl+Alt+F2, boot messages, emergency mode). Desktop environments like GNOME/KDE have their own keyboard settings configured separately.\nTest keymap immediately (before reboot):\n#| eval: false\nloadkeys de-latin1\nType some characters to verify the layout is correct.\n\n\n1.4.5 Step 4.4: Network Configuration\nProper network setup ensures you can connect to the internet after reboot.\n\n1.4.5.1 Set Hostname\n#| eval: false\necho \"arch-vm-config\" &gt; /etc/hostname\nWhat this does:\n\nCreates /etc/hostname with your chosen hostname\nHostname: Human-readable name identifying this machine\nUsed in network communications, shell prompt, logs\n\nHostname guidelines:\n\nOnly lowercase letters, numbers, and hyphens\nNo spaces or special characters\nShould be descriptive but concise\nExamples: arch-desktop, myarch, workstation, arch-vm\n\nWhy it matters:\n\nIdentifies your machine on networks\nAppears in router/DHCP listings\nUsed in Samba/network shares\nShows in terminal prompts\n\nVerify hostname:\n#| eval: false\ncat /etc/hostname\n\n\n1.4.5.2 Install NetworkManager\n#| eval: false\npacman -S networkmanager\nWhat this does:\n\nInstalls NetworkManager package\nNetworkManager: High-level network configuration tool\nManages Ethernet, Wi-Fi, VPN, mobile broadband\n\nWhy NetworkManager?\nAlternatives exist:\n\nsystemd-networkd: Simpler, built into systemd\nnetctl: Arch-specific, profile-based\ndhcpcd: Minimal, DHCP client only\n\nNetworkManager advantages:\n\nWorks with desktop environments (GNOME, KDE, Xfce)\nHas GUI tools (nm-applet, nm-connection-editor)\nHandles complex scenarios (VPN, multiple networks)\nAutomatic connection management\nWi-Fi support with GUI password prompts\n\nComponents installed:\n\nNetworkManager: Core daemon\nnmcli: Command-line interface\nLibraries for desktop environment integration\n\nDuring installation:\nresolving dependencies...\nlooking for conflicting packages...\n\nPackages (X) NetworkManager-1.44.2-3 ...\n\nTotal Download Size:    X.XX MiB\nTotal Installed Size:   X.XX MiB\n\n:: Proceed with installation? [Y/n]\nPress Enter or type y.\n\n\n1.4.5.3 Enable NetworkManager Service\n#| eval: false\nsystemctl enable NetworkManager\nWhat this does:\n\nCreates a symbolic link in systemd configuration\nNetworkManager will start automatically at boot\nWithout this, you’ll have no network after reboot\n\nUnderstanding systemd services:\n\nServices are background processes (daemons)\nSystemd manages service lifecycle (start, stop, restart)\nenable: Service starts at boot\nstart: Service starts now (but we can’t fully start in chroot)\n\nExpected output:\nCreated symlink /etc/systemd/system/multi-user.target.wants/NetworkManager.service → /usr/lib/systemd/system/NetworkManager.service.\nCreated symlink /etc/systemd/system/dbus-org.freedesktop.nm-dispatcher.service → /usr/lib/systemd/system/NetworkManager-dispatcher.service.\nCreated symlink /etc/systemd/system/network-online.target.wants/NetworkManager-wait-online.service → /usr/lib/systemd/system/NetworkManager-wait-online.service.\nWhat these symlinks mean:\n\nmulti-user.target.wants: Start when reaching multi-user runlevel\ndbus...: Enable D-Bus integration for event handling\nnetwork-online.target: Ensures network is up before dependent services\n\nVerify service is enabled:\n#| eval: false\nsystemctl is-enabled NetworkManager\nShould output: enabled\nCommon mistake:\n\nService name is NetworkManager (capital N, capital M)\nNot networkmanager or network-manager\nLinux service names are case-sensitive\n\n\n\n\n1.4.6 Step 4.5: Set Root Password\nThe root account has unlimited system privileges. Securing it is critical.\n#| eval: false\npasswd\nWhat this does:\n\nSets password for the current user (root, since we’re in chroot as root)\nPrompts you twice to ensure accuracy\nHashes and stores password in /etc/shadow\n\nPassword prompt:\nNew password: \nRetype new password: \npasswd: password updated successfully\nPassword best practices:\n\nLength: Minimum 12 characters (longer is better)\nComplexity: Mix uppercase, lowercase, numbers, symbols\nUniqueness: Don’t reuse passwords from other accounts\nMemorability: Use a passphrase (e.g., “correct-horse-battery-staple”)\n\nPassword strength examples:\n\n❌ Weak: password123, admin, 12345678\n⚠️ Fair: MyArch2024!\n✅ Strong: Tr0ub4dor&3 or correct-horse-battery-staple\n\nWhy set root password?\n\nEmergency access: If sudo breaks, you can log in as root\nSystem maintenance: Some tasks require root login\nSecurity: Prevents unauthorized root access\n\nImportant security note:\nYou’ll create a regular user account next. For daily use, you should:\n\nAlways use your regular account\nNever log in as root for routine tasks\nUse sudo for administrative commands\nRoot account is for emergencies and system recovery\n\n\n\n1.4.7 Step 4.6: Create User Account and Configure sudo\nRunning as root constantly is dangerous. A regular user account with sudo access is the secure approach.\n\n1.4.7.1 Create User Account\n#| eval: false\nuseradd -mG wheel -s /bin/bash myusername\nReplace myusername with your actual desired username.\nBreaking down the options:\n-m: Create home directory\n\nCreates /home/myusername/\nPopulates it with skeleton files from /etc/skel/\nWithout -m, user has no home directory\n\n-G wheel: Add user to supplementary group\n\nwheel: Traditional Unix group for users with sudo access\nGroup membership determines privileges\nUser can belong to multiple groups\n\n-s /bin/bash: Set login shell\n\nShell: Command interpreter user interacts with\n/bin/bash: Bourne Again Shell (most common)\nAlternatives: /bin/zsh, /bin/fish, /bin/sh\n\nUsername guidelines:\n\nLowercase letters only (convention)\nCan include numbers and underscores\nNo spaces or special characters\nExamples: john, alice, admin, myuser\n\nWhat gets created:\n\nEntry in /etc/passwd (user database)\nEntry in /etc/shadow (password hashes)\nEntry in /etc/group (group memberships)\nHome directory at /home/myusername/\n\nVerify user creation:\n#| eval: false\nid myusername\nExpected output:\nuid=1000(myusername) gid=1000(myusername) groups=1000(myusername),998(wheel)\nUnderstanding the output:\n\nuid=1000: User ID (first regular user gets 1000)\ngid=1000: Primary group ID\ngroups=...: All group memberships (including wheel)\n\n\n\n1.4.7.2 Set User Password\n#| eval: false\npasswd myusername\nWhat this does:\n\nSets password for the specified user\nSame process as setting root password\nThis password is used to log in as this user\n\nPassword considerations:\n\nCan be different from root password (recommended)\nShould still be strong (this is your daily account)\nYou’ll type this frequently, so balance security and convenience\nConsider using a password manager\n\n\n\n1.4.7.3 Install sudo\n#| eval: false\npacman -S sudo\nWhat sudo does:\n\nsudo: “Superuser do” - execute commands as root\nAllows temporary privilege elevation\nLogs all sudo commands (accountability)\nPrompts for user’s password (not root password)\n\nWhy sudo is essential:\n\nSecurity: Don’t run as root constantly\nAuditing: Logs who did what and when\nFlexibility: Per-command privilege escalation\nBest practice: Standard in modern Linux systems\n\nInstallation output:\nresolving dependencies...\nlooking for conflicting packages...\n\nPackages (1) sudo-1.9.x-x\n\nTotal Download Size:    X.XX MiB\nTotal Installed Size:   X.XX MiB\n\n:: Proceed with installation? [Y/n]\n\n\n1.4.7.4 Configure sudo for wheel Group\n#| eval: false\nvisudo\nWhat this does:\n\nOpens /etc/sudoers in a safe editor\nvisudo: Checks syntax before saving (prevents lockout)\nNever edit /etc/sudoers directly with vim/nano\n\nWhy visudo is important:\n\nSyntax errors in /etc/sudoers can lock you out\nvisudo validates configuration before saving\nUses vi by default (vim in Arch)\nPrevents simultaneous editing\n\nWhat to find and edit:\nLook for this line (around line 85):\n# %wheel ALL=(ALL:ALL) ALL\nUncomment it (remove the #):\n%wheel ALL=(ALL:ALL) ALL\nUnderstanding this line:\n\n%wheel: Applies to members of the “wheel” group (% indicates group)\nFirst ALL: Rule applies on all hosts\n(ALL:ALL): Can run as any user and any group\nLast ALL: Can run all commands\n\nTranslation: “Members of wheel group can run any command as any user on any host.”\nAlternative configurations available:\n# %wheel ALL=(ALL:ALL) NOPASSWD: ALL\nUncomment this instead if you want sudo without password (less secure, convenient for VMs).\nSave and exit:\n\nIn vim: Press Esc, type :wq, press Enter\nvisudo will check syntax and save\n\nVerify sudo configuration:\nAfter creating your user, test (later after reboot):\n#| eval: false\nsudo -l\nShould show what you can run with sudo.\n\n\n\n1.4.8 Step 4.7: Install and Configure Bootloader (GRUB)\nThe bootloader is the first software that runs when you turn on the computer. It loads the Linux kernel.\n\n1.4.8.1 Install GRUB Packages\n#| eval: false\npacman -S grub efibootmgr\nPackage breakdown:\ngrub: - GRand Unified Bootloader - Most popular bootloader for Linux - Supports UEFI and BIOS - Handles multi-boot (Windows + Linux) - Highly configurable\nefibootmgr: - Manages UEFI boot entries - Required for UEFI systems - Modifies NVRAM boot order - Creates boot entries visible in BIOS/UEFI\nWhy GRUB?\nAlternatives exist:\n\nsystemd-boot: Simpler, UEFI-only\nrEFInd: Graphical, multi-OS focus\nLILO: Legacy, rarely used now\n\nGRUB advantages:\n\nMature, well-documented\nExtensive configuration options\nTheme support\nWorks everywhere (UEFI and BIOS)\nLarge community support\n\n\n\n1.4.8.2 Install GRUB to EFI Partition\n#| eval: false\ngrub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB\nBreaking down each option:\n--target=x86_64-efi: - Specifies the platform architecture - x86_64: 64-bit x86 processor - efi: UEFI firmware (not BIOS) - Determines which GRUB binary to use\n--efi-directory=/boot/efi: - Location of the EFI System Partition mount - Where GRUB will install its .efi files - Must match where you mounted /dev/sda1\n--bootloader-id=GRUB: - Name for this bootloader in UEFI menu - Creates /boot/efi/EFI/GRUB/ directory - Shows up as “GRUB” in BIOS boot selection\nWhat this command does:\n\nCopies GRUB files to /boot/efi/EFI/GRUB/\nCreates grubx64.efi (the actual bootloader)\nRegisters boot entry in UEFI firmware\nSets up fallback boot path\n\nExpected output:\nInstalling for x86_64-efi platform.\nInstallation finished. No error reported.\nVerify installation:\n#| eval: false\nls /boot/efi/EFI/GRUB/\nShould show:\ngrubx64.efi  grub.cfg  ...\nCheck UEFI boot entries:\n#| eval: false\nefibootmgr\nExpected output:\nBootCurrent: 0001\nTimeout: 1 seconds\nBootOrder: 0000,0001\nBoot0000* GRUB\nBoot0001* UEFI OS\n\nBoot0000* GRUB: Your new GRUB entry\nBootOrder: Boot sequence (GRUB is first)\n\n\n\n1.4.8.3 Generate GRUB Configuration\n#| eval: false\ngrub-mkconfig -o /boot/grub/grub.cfg\nWhat this does:\n\nScans for installed operating systems\nDetects installed kernels\nCreates /boot/grub/grub.cfg (GRUB menu configuration)\nReads settings from /etc/default/grub\n\nExpected output:\nGenerating grub configuration file ...\nFound linux image: /boot/vmlinuz-linux\nFound initrd image: /boot/initramfs-linux.img\nFound fallback initrd image: /boot/initramfs-linux-fallback.img\ndone\nUnderstanding the output:\nvmlinuz-linux: - The Linux kernel itself - Compressed kernel image - This is what GRUB loads into memory\ninitramfs-linux.img: - Initial RAM filesystem - Contains drivers needed to mount real root filesystem - Loaded before actual root is mounted\ninitramfs-linux-fallback.img: - Fallback initramfs with all possible drivers - Used if regular initramfs fails to boot - Larger but more compatible\nThe generated configuration:\n#| eval: false\ncat /boot/grub/grub.cfg\nShows auto-generated menu entries:\nmenuentry 'Arch Linux' --class arch --class gnu-linux ... {\n    load_video\n    set gfxpayload=keep\n    insmod gzio\n    insmod part_gpt\n    insmod btrfs\n    search --no-floppy --fs-uuid --set=root &lt;uuid&gt;\n    echo 'Loading Linux linux ...'\n    linux /@/boot/vmlinuz-linux root=UUID=&lt;uuid&gt; rw rootflags=subvol=@ ...\n    echo 'Loading initial ramdisk ...'\n    initrd /@/boot/initramfs-linux.img\n}\nKey elements:\n\nsearch: Finds root partition by UUID\nlinux: Loads kernel with root location and options\nrootflags=subvol=@: Tells kernel to mount @ subvolume as root\ninitrd: Loads initial RAM disk\n\nCustomizing GRUB (optional):\nEdit /etc/default/grub:\n#| eval: false\nvim /etc/default/grub\nUseful settings:\nGRUB_TIMEOUT=5                    # Time before auto-boot (seconds)\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\"  # Kernel parameters\nGRUB_GFXMODE=1920x1080x32        # Resolution\nAfter editing, regenerate config:\n#| eval: false\ngrub-mkconfig -o /boot/grub/grub.cfg\n\n\n\n1.4.9 Step 4.8: Install VMware Tools\nThese tools improve integration between host and guest VM.\n#| eval: false\npacman -S open-vm-tools\nWhat open-vm-tools provides:\nCore functionality:\n\nShared clipboard: Copy/paste between host and VM\nDrag and drop: Files between host and VM\nShared folders: Access host directories from VM\nTime synchronization: Keep VM time accurate\nDisplay resolution: Auto-adjust to window size\n\nAdditional features:\n\nMemory ballooning: Dynamic memory allocation\nSnapshots: Better quiescing for VM snapshots\nGuest info: Reports VM state to host\nUnity mode: Seamless window integration (on some hosts)\n\nWhy open-vm-tools?\n\nOpen-source alternative to VMware Tools\nMaintained by VMware\nIncluded in Linux kernel\nBetter integration with modern systems\nNo need to install from VMware ISO\n\n\n1.4.9.1 Enable VMtools Service\n#| eval: false\nsystemctl enable vmtoolsd.service\nWhat this does:\n\nEnables the VMware Tools daemon to start at boot\nDaemon runs in background providing host integration\nWithout this, features won’t work after reboot\n\nExpected output:\nCreated symlink /etc/systemd/system/multi-user.target.wants/vmtoolsd.service → /usr/lib/systemd/system/vmtoolsd.service.\nAdditional services (optional):\n#| eval: false\nsystemctl enable vmware-vmblock-fuse.service  # For drag-and-drop\nVerify after reboot:\n#| eval: false\nsystemctl status vmtoolsd\nShould show active (running).\nTest functionality:\n\nResize VM window - desktop should auto-resize\nCopy text in host - paste in VM\nCheck time sync: timedatectl",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#phase-5-finalize-and-reboot",
    "href": "content/minimal_install_intro.html#phase-5-finalize-and-reboot",
    "title": "1  Introduction",
    "section": "1.5 Phase 5: Finalize and Reboot",
    "text": "1.5 Phase 5: Finalize and Reboot\n\n1.5.1 Step 5.1: Exit Chroot\n#| eval: false\nexit\nWhat this does:\n\nExits the chroot environment\nReturns to the live environment\nPrompt changes back to root@archiso ~ #\n\nYou’re now “outside” the installed system again.\n\n\n1.5.2 Step 5.2: Unmount All Partitions\n#| eval: false\numount -R /mnt\nWhat this does:\n\n-R: Recursive unmount\nUnmounts /mnt and all mountpoints under it\nEnsures all data is written to disk (flushes buffers)\n\nWhy this is important:\n\nPending writes are flushed to disk\nPrevents data corruption\nClean shutdown of filesystems\nBtrfs metadata is finalized\n\nWhat gets unmounted:\n\n/mnt/boot/efi (EFI partition)\n/mnt/home (home subvolume)\n/mnt/var/cache/pacman/pkg (package cache subvolume)\n/mnt (root subvolume)\n\nIf unmount fails:\n#| eval: false\nlsof +D /mnt  # See what's using /mnt\nfuser -km /mnt  # Kill processes using /mnt (careful!)\numount -R /mnt  # Try again\nVerify everything is unmounted:\n#| eval: false\nlsblk\nShould show no mountpoints under /mnt:\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0   20G  0 disk \n├─sda1   8:1    0  512M  0 part \n├─sda2   8:2    0    2G  0 part [SWAP]\n└─sda3   8:3    0 17.5G  0 part \n\n\n1.5.3 Step 5.3: Reboot into New System\n#| eval: false\nreboot\nWhat happens:\n\nSystem initiates shutdown sequence\nAll remaining filesystems unmounted\nSwap deactivated\nVM reboots\nCRITICAL: GRUB should load from disk\n\n🔥 IMPORTANT: Remove Installation Media\nImmediately after typing reboot:\n\nGo to VMware menu: VM → Settings\nSelect CD/DVD (SATA)\nUncheck “Connect at power on”\nOr change to “Use physical drive”\nClick OK\n\nIf you forget:\n\nVM will boot the Arch ISO again (live environment)\nYou’ll be back at the installation environment\nSimply remove the ISO and reboot again\n\nFirst boot sequence:\n\nVMware UEFI firmware initializes\nGRUB loads from /boot/efi/EFI/GRUB/grubx64.efi\nGRUB menu appears (5-second timeout)\nKernel loads with initramfs\nSystemd starts as init (PID 1)\nServices start (NetworkManager, etc.)\nGetty starts on TTY1 (login prompt)\n\nExpected login prompt:\nArch Linux 6.x.x-arch1-1 (tty1)\n\narch-vm-config login: _\nLogin as your user:\n\nUsername: Your created username\nPassword: User password you set\n\nFirst commands to run:\n#| eval: false\n# Check network\nip addr show\nping archlinux.org\n\n# Update system\nsudo pacman -Syu\n\n# Check disk usage\ndf -h\n\n# View mounted subvolumes\nmount | grep btrfs",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#post-installation-understanding-your-system",
    "href": "content/minimal_install_intro.html#post-installation-understanding-your-system",
    "title": "1  Introduction",
    "section": "1.6 Post-Installation: Understanding Your System",
    "text": "1.6 Post-Installation: Understanding Your System\n\n1.6.1 What You’ve Built\nYou now have:\n\nUEFI-bootable system: Modern boot process with GRUB\nBtrfs filesystem: With subvolumes for flexibility\nMinimal base: Only essential packages installed\nUser account: With sudo privileges\nNetwork: Configured and automatic\nVM integration: Open-vm-tools for host integration\n\n\n\n1.6.2 System Architecture Overview\nHardware (VMware VM)\n    ↓\nUEFI Firmware\n    ↓\nGRUB Bootloader (/boot/efi/EFI/GRUB/grubx64.efi)\n    ↓\nLinux Kernel (/boot/vmlinuz-linux)\n    ↓\nInitramfs (/boot/initramfs-linux.img)\n    ↓\nSystemd (PID 1)\n    ↓\nSystem Services (NetworkManager, vmtoolsd, etc.)\n    ↓\nGetty (Login Prompt)\n    ↓\nUser Shell (Bash)\n\n\n1.6.3 File System Structure\n/ (root)                          - @ subvolume on /dev/sda3\n├── boot/\n│   ├── efi/                      - /dev/sda1 (FAT32, EFI partition)\n│   │   └── EFI/GRUB/\n│   ├── vmlinuz-linux             - Kernel\n│   └── initramfs-linux.img       - Initial RAM disk\n├── home/                         - @home subvolume on /dev/sda3\n│   └── myusername/\n├── var/\n│   └── cache/pacman/pkg/         - @pkg subvolume on /dev/sda3\n├── etc/                          - System configuration\n│   ├── fstab                     - Mount points\n│   ├── hostname                  - System name\n│   ├── locale.conf               - System language\n│   ├── vconsole.conf             - Console keymap\n│   └── sudoers                   - Sudo configuration\n└── usr/                          - Installed software\n    ├── bin/                      - Executables\n    └── lib/                      - Libraries\n\n\n1.6.4 Btrfs Subvolume Layout\n/dev/sda3 (Btrfs filesystem \"ArchRoot\")\n├── @ subvolume        → mounted at /\n├── @home subvolume    → mounted at /home\n└── @pkg subvolume     → mounted at /var/cache/pacman/pkg\nBenefits of this layout:\n\nSnapshot root without home\nSeparate package cache from snapshots\nIndependent rollback of system vs. data\nEfficient space usage with compression\n\n\n\n1.6.5 Key Configuration Files\n\n\n\n\n\n\n\n\nFile\nPurpose\nKey Settings\n\n\n\n\n/etc/fstab\nDefines mount points for boot\nUUID-based mounts, Btrfs subvolumes\n\n\n/etc/hostname\nSystem name on network\nYour chosen hostname\n\n\n/etc/locale.conf\nSystem language\nLANG=en_US.UTF-8\n\n\n/etc/vconsole.conf\nConsole keyboard layout\nKEYMAP=de-latin1\n\n\n/etc/locale.gen\nAvailable locales\nUncommented locales to generate\n\n\n/etc/sudoers\nSudo permissions\n%wheel ALL=(ALL:ALL) ALL\n\n\n/boot/grub/grub.cfg\nGRUB menu configuration\nAuto-generated, defines boot entries\n\n\n/etc/default/grub\nGRUB settings\nTimeout, kernel parameters, themes\n\n\n\n\n\n1.6.6 Understanding Package Management\nPacman basics:\n#| eval: false\n# Update package database\nsudo pacman -Sy\n\n# Upgrade all packages\nsudo pacman -Syu\n\n# Install package\nsudo pacman -S package_name\n\n# Remove package\nsudo pacman -R package_name\n\n# Search for package\npacman -Ss search_term\n\n# Query installed packages\npacman -Q\n\n# Get package info\npacman -Qi package_name\n\n# Clean package cache\nsudo pacman -Sc\nPackage repositories:\n\ncore: Essential packages\nextra: Additional official packages\nmultilib: 32-bit support (optional)\nAUR: Community-maintained (requires helper like yay)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#next-steps-building-your-desktop-environment",
    "href": "content/minimal_install_intro.html#next-steps-building-your-desktop-environment",
    "title": "1  Introduction",
    "section": "1.7 Next Steps: Building Your Desktop Environment",
    "text": "1.7 Next Steps: Building Your Desktop Environment\nYour minimal system is a foundation. Here’s the typical path forward:\n\n1.7.1 1. Install Display Server\nXorg (most compatible):\n#| eval: false\nsudo pacman -S xorg-server xorg-xinit\nOr Wayland (modern):\n#| eval: false\nsudo pacman -S wayland\n\n\n1.7.2 2. Install Window Manager or Desktop Environment\nMinimal (Window Manager):\n#| eval: false\n# i3 (tiling window manager)\nsudo pacman -S i3-wm i3status i3lock dmenu\n\n# Or Sway (i3 for Wayland)\nsudo pacman -S sway swaylock swayidle\nFull Desktop (Desktop Environment):\n#| eval: false\n# GNOME\nsudo pacman -S gnome gnome-extra\n\n# KDE Plasma\nsudo pacman -S plasma kde-applications\n\n# Xfce (lightweight)\nsudo pacman -S xfce4 xfce4-goodies\n\n\n1.7.3 3. Install Essential Applications\n#| eval: false\n# Terminal emulator\nsudo pacman -S alacritty  # or kitty, st\n\n# Web browser\nsudo pacman -S firefox\n\n# File manager\nsudo pacman -S thunar  # or nautilus, dolphin\n\n# Text editor\nsudo pacman -S neovim  # or gedit, kate\n\n# Development tools\nsudo pacman -S base-devel git\n\n\n1.7.4 4. Display Manager (Login Screen)\n#| eval: false # LightDM (lightweight) sudo pacman -S lightdm lightdm-gtk-greeter sudo systemctl enable lightdm",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#pre-installation-checks",
    "href": "content/minimal_install_intro.html#pre-installation-checks",
    "title": "2  Manual Arch Linux Installation",
    "section": "2.2 Pre-Installation Checks",
    "text": "2.2 Pre-Installation Checks\nBefore installing, verify that the live environment is configured correctly.\n\n2.2.1 Verify Boot Mode\nls /sys/firmware/efi/efivars\nWhat this does: Checks if the system booted in UEFI mode. If the directory exists and contains files, you’re in UEFI mode. This is important because the bootloader installation later depends on the boot mode.\nWhy it matters: Modern systems use UEFI instead of legacy BIOS. UEFI provides better security features and faster boot times. The presence of efivars confirms the firmware interface is accessible.\n\n\n2.2.2 Verify Network Connectivity\nping archlinux.org\nWhat this does: Sends network packets to verify internet connectivity. Press Ctrl+C to stop.\nWhy it matters: The installation requires downloading packages from remote repositories. The live environment typically configures networking automatically via DHCP, but it’s essential to verify before proceeding.\n\n\n2.2.3 Update System Clock\ntimedatectl set-ntp true\nWhat this does: Enables Network Time Protocol (NTP) synchronization, ensuring the system clock is accurate.\nWhy it matters: Accurate timestamps are crucial for package management, encryption, and system logs. Many security protocols depend on synchronized time.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manual Arch Linux Installation</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#disk-partitioning-and-preparation",
    "href": "content/minimal_install_intro.html#disk-partitioning-and-preparation",
    "title": "2  Manual Arch Linux Installation",
    "section": "2.3 Disk Partitioning and Preparation",
    "text": "2.3 Disk Partitioning and Preparation\nThis section creates the disk structure: an EFI partition for the bootloader, a swap partition for memory overflow, and a Btrfs partition for the root filesystem.\n\n2.3.1 Understanding the Layout\n\nEFI Partition (512MB): Stores bootloader files. Must be FAT32 format.\nSwap Partition (2GB): Acts as overflow when RAM is full. Size typically matches RAM for systems with ≤8GB.\nRoot Partition (Remaining): Contains the entire Linux system using Btrfs filesystem.\n\n\n\n2.3.2 Partition the Disk\ncfdisk /dev/sda\nWhat this does: Opens an interactive partition editor. The disk is typically /dev/sda in virtual machines.\nStep-by-step:\n\nSelect gpt when prompted. GPT (GUID Partition Table) is required for UEFI and supports disks larger than 2TB.\nCreate the EFI partition:\n\nSelect New → Enter 512M\nNavigate to Type → Select EFI System\n\nCreate the swap partition:\n\nSelect New → Enter 2G\nNavigate to Type → Select Linux swap\n\nCreate the root partition:\n\nSelect New → Press Enter (uses remaining space)\nType should default to Linux filesystem\n\nSelect Write → Type yes → Select Quit\n\nWhy these choices: GPT is modern and required for UEFI. The 512MB EFI partition provides ample space for multiple kernels. The 2GB swap allows basic memory management without wasting disk space.\n\n\n2.3.3 Format the Partitions\nFormatting creates filesystems on the raw partitions, making them usable by the operating system.\nmkfs.fat -F32 /dev/sda1         # EFI partition\nmkswap /dev/sda2                # Swap partition\nswapon /dev/sda2                # Activate swap\nmkfs.btrfs -L ArchRoot /dev/sda3  # Root partition\nWhat each command does:\n\nmkfs.fat -F32: Creates a FAT32 filesystem (required for EFI).\nmkswap: Prepares the partition for use as swap space.\nswapon: Activates swap immediately for the installation process.\nmkfs.btrfs -L ArchRoot: Creates a Btrfs filesystem with the label “ArchRoot”.\n\nWhy Btrfs: Btrfs offers advanced features like snapshots, compression, and subvolumes. Subvolumes allow separate management of different directory trees while sharing the same filesystem.\n\n\n2.3.4 Create and Mount Btrfs Subvolumes\nSubvolumes provide flexibility for snapshots and separate management of system components.\nmount /dev/sda3 /mnt\nWhat this does: Temporarily mounts the Btrfs partition to create subvolumes.\nbtrfs subvolume create /mnt/@\nbtrfs subvolume create /mnt/home\nbtrfs subvolume create /mnt/@pkg\nWhat this does: Creates three subvolumes:\n\n@: The root filesystem (follows Btrfs naming convention)\nhome: User home directories\n@pkg: Package cache at /var/cache/pacman/pkg\n\nWhy separate subvolumes: This allows independent snapshots of the root system without including user data or the package cache. You can restore the system without affecting personal files.\n\n\n2.3.5 Remount with Optimizations\numount /mnt\nmount -o compress=zstd,noatime,subvol=@ /dev/sda3 /mnt\nWhat this does: Unmounts the filesystem, then remounts the root subvolume with specific options.\nMount options explained:\n\ncompress=zstd: Enables transparent compression using Zstandard algorithm. Saves disk space and can improve performance on modern CPUs.\nnoatime: Disables recording file access times, reducing write operations and improving performance.\nsubvol=@: Mounts the root subvolume specifically.\n\n\n\n2.3.6 Mount Remaining Subvolumes and EFI\nmkdir -p /mnt/{boot/efi,home,var/cache/pacman/pkg}\nmount -o compress=zstd,noatime,subvol=home /dev/sda3 /mnt/home\nmount -o compress=zstd,noatime,subvol=@pkg /dev/sda3 /mnt/var/cache/pacman/pkg\nmount /dev/sda1 /mnt/boot/efi\nWhat this does:\n\nCreates necessary directories under /mnt\nMounts home subvolume to /mnt/home\nMounts @pkg subvolume to the pacman cache location\nMounts the EFI partition to /mnt/boot/efi\n\nVerification: Run lsblk to view the partition structure and confirm all mounts are correct.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manual Arch Linux Installation</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#installing-the-base-system",
    "href": "content/minimal_install_intro.html#installing-the-base-system",
    "title": "2  Manual Arch Linux Installation",
    "section": "2.4 Installing the Base System",
    "text": "2.4 Installing the Base System\n\n2.4.1 Configure Package Mirrors\nBefore installing packages, it’s beneficial to optimize the mirror list for faster downloads.\nvim /etc/pacman.d/mirrorlist\nWhat this file contains: A list of all available Arch Linux repository mirrors worldwide. The package manager (pacman) reads this file from top to bottom and uses the first working mirror it encounters.\nWhy mirror selection matters: Geographically closer mirrors typically provide faster download speeds, reducing installation time and improving future system updates.\n\n2.4.1.1 Understanding Mirror Geography\nThe mirrorlist contains mirrors from various locations globally:\n\nGermany (DE): de.arch.niran.jan.co, arch.phinau.de, berlin.mirror.pkgbuild.com\nUnited States (US): us.arch.mirror.constant.com, losangeles.mirror.pkgbuild.com\nSingapore: singapore.mirror.pkgbuild.com\nSouth Africa: johannesburg.mirror.pkgbuild.com\nEurope (General): mirror.xtom.ee, archlinux.tk-leaf.net\n\n\n\n2.4.1.2 Prioritizing Your Nearest Mirrors\nSteps to reorder mirrors:\n\nIn vim, navigate using arrow keys to locate mirrors closest to your location\nPosition your cursor on the line of your preferred mirror\nPress dd to cut (delete) the entire line\nMove to the top of the list (below the comment headers)\nPress p to paste the line\nRepeat for additional nearby mirrors to create a prioritized list\n\nExample for Germany: You would move these mirrors to the top:\nServer = https://de.arch.niran.jan.co/$repo/os/$arch\nServer = https://arch.phinau.de/$repo/os/$arch\nServer = https://berlin.mirror.pkgbuild.com/$repo/os/$arch\nVim commands reference:\nVim operates in different modes. Understanding this is key to using it effectively:\n\nNormal mode (default): For navigation and commands\n\nj: Move down one line\nk: Move up one line\nArrow keys: Also work for navigation (up, down, left, right)\ndd: Cut (delete) the current line\np: Paste below the cursor\n\nInsert mode: For typing text\n\ni: Enter insert mode (you’ll see -- INSERT -- at the bottom)\nIn insert mode, j and k type the letters ‘j’ and ‘k’ instead of moving\nArrow keys still work for navigation even in insert mode\n\nCommand mode: For saving and quitting\n\nESC: Return to normal mode from any other mode\n:wq: Write (save) and quit\n:q!: Quit without saving (if you make a mistake)\n\n\nQuick tip: If you’re unsure which mode you’re in, press ESC to return to normal mode.\nSaving and exiting:\n\nPress ESC to ensure you’re in normal mode\nType :wq and press Enter\n\nThis prioritization ensures faster downloads throughout the installation and for future system updates.\n\n\n\n2.4.2 Understanding pacstrap\nThe pacstrap script installs packages to a specified directory, creating the foundation of your Arch system.\npacstrap /mnt base linux linux-firmware vim\nWhat this installs:\n\nbase: Meta-package containing essential system utilities\nlinux: The Linux kernel\nlinux-firmware: Binary firmware files for common hardware\nvim: Text editor (you can substitute with nano if preferred)\n\nWhy these packages: The base package provides the bare minimum for a bootable system. The kernel is the operating system core. Firmware enables hardware like WiFi cards and graphics adapters. A text editor is essential for configuration.\n\n\n2.4.3 Generate fstab\ngenfstab -U /mnt &gt;&gt; /mnt/etc/fstab\nWhat this does: Creates the /etc/fstab file, which defines how partitions and subvolumes mount at boot.\nThe -U flag: Uses UUIDs (Universally Unique Identifiers) instead of device names. UUIDs remain consistent even if device naming changes, making the system more robust.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manual Arch Linux Installation</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#bootloader-installation",
    "href": "content/minimal_install_intro.html#bootloader-installation",
    "title": "2  Manual Arch Linux Installation",
    "section": "2.6 Bootloader Installation",
    "text": "2.6 Bootloader Installation\nThe bootloader is what starts your operating system when the computer powers on.\npacman -S grub efibootmgr\ngrub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB\ngrub-mkconfig -o /boot/grub/grub.cfg\nWhat each command does:\n\nInstalls GRUB (bootloader) and efibootmgr (manages EFI boot entries)\nInstalls GRUB to the EFI partition:\n\n--target=x86_64-efi: Specifies UEFI mode for 64-bit systems\n--efi-directory=/boot/efi: Location of the EFI partition\n--bootloader-id=GRUB: Name shown in the firmware boot menu\n\nGenerates GRUB configuration file (detects kernels and creates boot menu)\n\n\n2.6.1 VM Tools (Virtual Machine Only)\npacman -S open-vm-tools\nsystemctl enable vmtoolsd.service\nWhat this does: Installs VMware integration tools for better mouse handling, clipboard sharing, and display resolution.\nSkip this step if installing on physical hardware.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manual Arch Linux Installation</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#completing-installation",
    "href": "content/minimal_install_intro.html#completing-installation",
    "title": "2  Manual Arch Linux Installation",
    "section": "2.7 Completing Installation",
    "text": "2.7 Completing Installation\n\n2.7.1 Exit and Reboot\nexit\numount -R /mnt\nreboot\nWhat this does:\n\nExits the chroot environment\nRecursively unmounts all filesystems under /mnt\nReboots the system\n\nCritical: Before the system restarts, remove the installation ISO from your VM settings (or physical USB drive). The system should now boot from the hard disk.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manual Arch Linux Installation</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#first-boot",
    "href": "content/minimal_install_intro.html#first-boot",
    "title": "2  Manual Arch Linux Installation",
    "section": "2.8 First Boot",
    "text": "2.8 First Boot\nAfter rebooting, you’ll see a login prompt. Log in with your username and password.\nYou now have: A minimal, command-line Arch Linux system. No graphical interface yet—just a terminal.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manual Arch Linux Installation</span>"
    ]
  },
  {
    "objectID": "content/minimal_install_intro.html#key-takeaways",
    "href": "content/minimal_install_intro.html#key-takeaways",
    "title": "2  Manual Arch Linux Installation",
    "section": "2.10 Key Takeaways",
    "text": "2.10 Key Takeaways\n\nManual installation teaches system architecture by requiring interaction with each component\nBtrfs subvolumes enable flexible snapshot management\nProper partitioning separates bootloader, swap, and system data\nThe chroot environment allows system configuration before first boot\nStarting minimal allows you to understand each layer you add\n\nThis foundation provides complete control over your Linux system and prepares you for advanced customization.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manual Arch Linux Installation</span>"
    ]
  },
  {
    "objectID": "index.html#what-this-book-is",
    "href": "index.html#what-this-book-is",
    "title": "Arch Linux Installation and Setup Personal Guide",
    "section": "1.1 What This Book Is",
    "text": "1.1 What This Book Is\nA living document that grows with my understanding of Arch Linux. Each chapter represents a milestone in learning how Linux works at a fundamental level, starting from manual installation and building up to a fully customized system.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "index.html#what-this-book-is-not",
    "href": "index.html#what-this-book-is-not",
    "title": "Arch Linux Installation and Setup Personal Guide",
    "section": "1.2 What This Book Is Not",
    "text": "1.2 What This Book Is Not\n\nA complete reference manual\nA step-by-step tutorial for every scenario\nA replacement for the Arch Wiki",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "index.html#why-arch",
    "href": "index.html#why-arch",
    "title": "Arch Linux Installation and Setup Personal Guide",
    "section": "1.3 Why Arch?",
    "text": "1.3 Why Arch?\nArch Linux forces you to understand your system by building it piece by piece. Every component you install, every configuration file you edit, and every service you enable teaches you how modern Linux systems work.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "index.html#who-this-is-for",
    "href": "index.html#who-this-is-for",
    "title": "Arch Linux Installation and Setup Personal Guide",
    "section": "1.4 Who This Is For",
    "text": "1.4 Who This Is For\nPrimarily myself—as a reference for future installations and a record of lessons learned. However, if you’re also learning Arch Linux from scratch and want to see one person’s documented journey, you might find this useful.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "index.html#structure",
    "href": "index.html#structure",
    "title": "Arch Linux Installation and Setup Personal Guide",
    "section": "1.5 Structure",
    "text": "1.5 Structure\nThe book follows my actual learning path: 1. Manual installation (understanding the foundation) 2. Desktop environment setup (as I configure it) 3. Daily use configurations (as I discover them) 4. Advanced topics (as I encounter and solve them)\nChapters will be added and refined as I continue exploring Arch Linux on my journey toward setting up my new physical machine.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  }
]
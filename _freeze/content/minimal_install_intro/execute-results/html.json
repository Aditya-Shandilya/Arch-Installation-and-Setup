{
  "hash": "3892ef7b5b26db6e06fe45b26005930f",
  "result": {
    "engine": "jupyter",
    "markdown": "## Introduction\n\nThis chapter documents the complete manual installation of Arch Linux on a VMware virtual machine. Unlike automated installers, this hands-on approach ensures you understand every component of your system—from bootloaders to file systems. This knowledge forms the foundation for managing and troubleshooting Linux systems effectively.\n\nThe installation follows the \"Arch Way\": simplicity, user-centrality, and pragmatism. By the end, you'll have a minimal, command-line Arch Linux system ready for customization.\n\n### Why Manual Installation?\n\nManual installation teaches you:\n\n- **Boot process fundamentals**: How UEFI, bootloaders, and kernels interact\n- **File system architecture**: The purpose of partitions and mount points\n- **System initialization**: How services start and what they do\n- **Package management**: Building systems from minimal components\n\nThis knowledge is invaluable when troubleshooting, customizing, or understanding any Linux distribution.\n\n## Phase 1: Pre-Installation Checks\n\n### Understanding the Live Environment\n\nWhen you boot the Arch Linux ISO, you're running a complete, temporary Linux system in RAM. This \"live environment\" provides all the tools needed to install Arch on your disk. Nothing you do here persists after reboot—it's a clean slate every time.\n\n### Step 1.1: Verify Boot Mode (UEFI vs BIOS)\n\nModern systems use UEFI (Unified Extensible Firmware Interface), which replaced the legacy BIOS. Verifying your boot mode is critical because the bootloader installation differs significantly between the two.\n```{bash}\n#| eval: false\nls /sys/firmware/efi/efivars\n```\n\n**What this does:**\n\n- Lists the contents of the `efivars` directory\n- This directory only exists when booted in UEFI mode\n- The directory contains firmware variables that the OS can read/write\n\n**Expected output:**\n\nIf you see a list of files (with names like `Boot0000-...`, `BootCurrent-...`), you're in UEFI mode. This is what we want.\n\n**If the directory doesn't exist:**\n\nYou've booted in legacy BIOS mode. You'll need to:\n\n1. Shut down the VM\n2. Go to VMware settings → Options → Advanced\n3. Change \"Firmware type\" to \"UEFI\"\n4. Restart with the Arch ISO\n\n**Why UEFI matters:**\n\n- UEFI requires a special FAT32 partition (ESP - EFI System Partition)\n- UEFI uses `.efi` bootloader files instead of installing to the MBR\n- UEFI provides better security features (Secure Boot support)\n- UEFI is mandatory for disks larger than 2TB with GPT\n\n### Step 1.2: Verify Network Connectivity\n\nThe Arch installation requires downloading packages from internet repositories. The live environment typically configures network automatically via DHCP.\n```{bash}\n#| eval: false\nping archlinux.org\n```\n\n**What this does:**\n\n- Sends ICMP echo requests to `archlinux.org`\n- Tests both DNS resolution and internet connectivity\n- Continues indefinitely until you stop it\n\n**Expected output:**\n```\n64 bytes from archlinux.org (95.217.163.246): icmp_seq=1 ttl=54 time=12.3 ms\n64 bytes from archlinux.org (95.217.163.246): icmp_seq=2 ttl=54 time=11.8 ms\n```\n\nPress `Ctrl+C` to stop after confirming connectivity.\n\n**If ping fails:**\n\nFor VMware, network should work automatically. If not:\n\n1. Check VMware network adapter settings (should be NAT or Bridged)\n2. Verify the VM has a network adapter attached\n3. Try `ip link` to see network interfaces\n4. For Wi-Fi (on physical machines), use `iwctl` to connect\n\n**Understanding the output:**\n\n- `64 bytes`: Size of the reply packet\n- `icmp_seq`: Sequence number (increments with each ping)\n- `ttl=54`: Time To Live (hops remaining before packet is discarded)\n- `time=12.3 ms`: Round-trip latency\n\n### Step 1.3: Update System Clock\n\nAccurate system time is crucial for several reasons: SSL/TLS certificate validation, file timestamps, and system logs.\n```{bash}\n#| eval: false\ntimedatectl set-ntp true\n```\n\n**What this does:**\n\n- Enables Network Time Protocol (NTP) synchronization\n- The system will automatically sync time with internet time servers\n- Uses `systemd-timesyncd` service in the background\n\n**Verify synchronization:**\n```{bash}\n#| eval: false\ntimedatectl status\n```\n\nLook for `System clock synchronized: yes` and `NTP service: active`.\n\n**Why this matters:**\n\n- **Package installation**: Repository mirrors use timestamps; incorrect time can cause validation failures\n- **SSL/TLS**: HTTPS connections fail if your clock is off by more than a few minutes\n- **Logging**: Installation logs need accurate timestamps for troubleshooting\n\n## Phase 2: Disk Partitioning and File System Setup\n\n### Understanding Disk Layout\n\nBefore partitioning, it's essential to understand what we're creating:\n\n1. **EFI System Partition (ESP)**: Stores bootloader files (`.efi` binaries)\n2. **Swap Partition**: Virtual memory extension (for hibernation and memory overflow)\n3. **Root Partition**: Contains the entire Linux file system\n\n### Why Btrfs?\n\nWe're using Btrfs (B-tree File System) instead of ext4 because it offers:\n\n- **Subvolumes**: Logical divisions within a partition that can be mounted independently\n- **Snapshots**: Instant, space-efficient backups of subvolumes\n- **Compression**: Transparent, on-the-fly data compression (saves disk space)\n- **Copy-on-Write (CoW)**: Data integrity and efficient copying\n\n**Subvolume strategy:**\n\n- `@`: Root file system (`/`)\n- `@home`: User data (`/home`)\n- `@pkg`: Package cache (`/var/cache/pacman/pkg`)\n\nThis separation allows you to snapshot the root system without including user data or take separate home directory snapshots.\n\n### Step 2.1: Partition the Disk\n\nWe'll use `cfdisk`, which provides a user-friendly text interface compared to `fdisk`.\n```{bash}\n#| eval: false\ncfdisk /dev/sda\n```\n\n**What this does:**\n\n- Launches the curses-based disk partitioning utility\n- `/dev/sda` is typically the first SATA/SCSI disk in the system\n- In VMware, your virtual disk appears as `/dev/sda`\n\n**Verify your disk:**\n\nBefore running `cfdisk`, check available disks:\n```{bash}\n#| eval: false\nlsblk\n```\n\nYou should see something like:\n```\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0   20G  0 disk \nsr0     11:0    1  800M  0 rom  /run/archiso/bootmnt\n```\n\n`sda` is your target disk (20GB as configured), `sr0` is the Arch ISO.\n\n**Partitioning workflow:**\n\n1. **Select partition table type**: Choose `gpt`\n   - GPT (GUID Partition Table) is the modern standard\n   - Supports disks >2TB\n   - Required for UEFI boot\n   - Stores partition data redundantly (more reliable)\n\n2. **Create EFI partition** (512 MiB):\n   - Navigate to free space\n   - Select `[ New ]`\n   - Enter size: `512M`\n   - Select `[ Type ]` → Choose `EFI System`\n   \n   **Why 512 MiB?**\n   - UEFI spec recommends 100-550 MiB\n   - 512 MiB provides room for multiple bootloaders (dual-boot scenarios)\n   - Larger size accommodates kernel backups in `/boot`\n\n3. **Create Swap partition** (2 GiB):\n   - Select remaining free space\n   - Select `[ New ]`\n   - Enter size: `2G`\n   - Select `[ Type ]` → Choose `Linux swap`\n   \n   **Swap size guidelines:**\n   - For hibernation: swap ≥ RAM size\n   - For 4GB RAM without hibernation: 2GB is adequate\n   - Modern systems with ample RAM need less swap\n   - Formula: `swap = √RAM` (rounded up) for systems with >2GB RAM\n\n4. **Create Root partition** (remaining space):\n   - Select remaining free space\n   - Select `[ New ]`\n   - Press Enter (accepts all remaining space)\n   - Type should default to `Linux filesystem` (correct for Btrfs)\n\n5. **Write changes**:\n   - Select `[ Write ]`\n   - Type `yes` (lowercase, exactly)\n   - Select `[ Quit ]`\n\n**Important notes:**\n\n- Changes aren't saved until you write them\n- Double-check partition sizes before writing\n- `cfdisk` automatically sector-aligns partitions for optimal performance\n\n**Verify partitions:**\n```{bash}\n#| eval: false\nlsblk\n```\n\nShould now show:\n```\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0   20G  0 disk \n├─sda1   8:1    0  512M  0 part \n├─sda2   8:2    0    2G  0 part \n└─sda3   8:3    0 17.5G  0 part \n```\n\n### Step 2.2: Format the Partitions\n\nFormatting creates a file system structure on the raw partition. This defines how data is stored and retrieved.\n\n#### Format EFI Partition\n```{bash}\n#| eval: false\nmkfs.fat -F32 /dev/sda1\n```\n\n**What this does:**\n\n- `mkfs.fat`: Creates a FAT file system\n- `-F32`: Specifies FAT32 (required by UEFI spec)\n- `/dev/sda1`: The EFI partition we created\n\n**Why FAT32?**\n\n- UEFI firmware can only read FAT12/FAT16/FAT32\n- FAT32 supports files up to 4GB (adequate for bootloaders)\n- Simple, universally compatible file system\n- No journaling (unnecessary for read-mostly bootloader files)\n\n**Expected output:**\n```\nmkfs.fat 4.2 (2021-01-31)\n```\n\n#### Format and Activate Swap\n```{bash}\n#| eval: false\nmkswap /dev/sda2\nswapon /dev/sda2\n```\n\n**What this does:**\n\n- `mkswap`: Writes swap signature and prepares the partition\n- `swapon`: Activates the swap partition immediately\n\n**Understanding swap:**\n\nSwap is a dedicated area on disk used as virtual memory. The kernel moves inactive memory pages to swap when RAM is full.\n\n**Verify swap:**\n```{bash}\n#| eval: false\nfree -h\n```\n\nYou should see your swap space listed:\n```\n              total        used        free      shared  buff/cache   available\nMem:          3.9Gi       200Mi       3.5Gi        10Mi       200Mi       3.6Gi\nSwap:         2.0Gi          0B       2.0Gi\n```\n\n**When is swap used?**\n\n- RAM is exhausted (prevents OOM killer)\n- Hibernation (RAM contents saved to swap)\n- Kernel moves rarely-used pages to swap proactively\n\n#### Format Root Partition with Btrfs\n```{bash}\n#| eval: false\nmkfs.btrfs -L ArchRoot /dev/sda3\n```\n\n**What this does:**\n\n- `mkfs.btrfs`: Creates a Btrfs file system\n- `-L ArchRoot`: Sets the file system label to \"ArchRoot\"\n- `/dev/sda3`: The root partition\n\n**File system label benefits:**\n\n- Human-readable identification\n- Can mount by label: `mount LABEL=ArchRoot /mnt`\n- Persists across partition renumbering\n- Visible in `lsblk -f` output\n\n**Expected output:**\n```\nbtrfs-progs v6.x.x\nSee http://btrfs.wiki.kernel.org for more information.\n\nLabel:              ArchRoot\nUUID:               [long UUID string]\nNode size:          16384\nSector size:        4096\nFilesystem size:    17.50GiB\n...\n```\n\n**Btrfs default features:**\n\n- **Copy-on-Write (CoW)**: Original data never overwritten\n- **Checksumming**: All data and metadata checksummed for integrity\n- **Multi-device support**: Can span multiple disks (we're using one)\n\n### Step 2.3: Create Btrfs Subvolumes\n\nSubvolumes are the key feature that makes Btrfs powerful for system management.\n\n#### Initial Mount\n```{bash}\n#| eval: false\nmount /dev/sda3 /mnt\n```\n\n**What this does:**\n\n- Mounts the Btrfs partition to `/mnt`\n- This is a temporary mount to create subvolumes\n- We're mounting the \"root\" of the Btrfs filesystem, not a subvolume yet\n\n#### Create Subvolumes\n```{bash}\n#| eval: false\nbtrfs subvolume create /mnt/@\nbtrfs subvolume create /mnt/@home\nbtrfs subvolume create /mnt/@pkg\n```\n\n**What this does:**\n\nEach command creates a new subvolume within the Btrfs filesystem.\n\n**Subvolume naming conventions:**\n\n- `@` prefix is a convention from Ubuntu/Timeshift (not mandatory)\n- `@`: Root subvolume (will be mounted at `/`)\n- `@home`: Home directories subvolume (will be mounted at `/home`)\n- `@pkg`: Package cache subvolume (will be mounted at `/var/cache/pacman/pkg`)\n\n**Why these specific subvolumes?**\n\n1. **`@` (root)**:\n   - Contains the OS: `/bin`, `/etc`, `/usr`, etc.\n   - Snapshot before system updates for easy rollback\n   - Can restore without affecting user data\n\n2. **`@home`**:\n   - Contains user data: documents, configs, downloads\n   - Snapshot independently of system\n   - Exclude from system snapshots (saves space)\n   - Preserve user data when reinstalling OS\n\n3. **`@pkg`**:\n   - Contains downloaded packages (`/var/cache/pacman/pkg`)\n   - Packages can be large (multi-GB cache)\n   - Exclude from snapshots (packages can be re-downloaded)\n   - Share across snapshots (avoid duplicating package cache)\n\n**Verify subvolumes:**\n```{bash}\n#| eval: false\nbtrfs subvolume list /mnt\n```\n\nExpected output:\n```\nID 256 gen 8 top level 5 path @\nID 257 gen 8 top level 5 path @home\nID 258 gen 8 top level 5 path @pkg\n```\n\n**Understanding the output:**\n\n- `ID`: Unique identifier for the subvolume\n- `gen`: Generation (changes with each modification)\n- `top level 5`: Parent subvolume (5 is the root container)\n- `path`: Subvolume path relative to Btrfs root\n\n#### Unmount for Proper Remounting\n```{bash}\n#| eval: false\numount /mnt\n```\n\n**Why unmount?**\n\nWe mounted the Btrfs root to create subvolumes. Now we need to mount the individual subvolumes with specific options. The Btrfs root itself isn't meant to be used directly.\n\n### Step 2.4: Mount Subvolumes with Options\n\nNow we'll mount each subvolume to its proper location with optimization flags.\n\n#### Mount Root Subvolume\n```{bash}\n#| eval: false\nmount -o compress=zstd,noatime,subvol=@ /dev/sda3 /mnt\n```\n\n**Breaking down the options:**\n\n**`-o`**: Specifies mount options (comma-separated list)\n\n**`compress=zstd`**:\n- Enables transparent compression using Zstandard algorithm\n- Data is compressed on write, decompressed on read\n- Happens automatically, applications don't notice\n- **Benefits**:\n  - Reduces disk space usage (typically 30-50% savings)\n  - Can improve read/write speeds (less data to transfer)\n  - Zstd offers excellent compression ratio and speed\n- **Alternatives**: `compress=lzo` (faster, lower ratio), `compress=zlib` (slower, higher ratio)\n\n**`noatime`**:\n- Disables access time updates\n- Normally, Linux updates a file's \"last access time\" on every read\n- **Benefits**:\n  - Reduces write operations (improves SSD lifespan)\n  - Improves performance (fewer metadata updates)\n  - Most applications don't need atime\n- **Alternative**: `relatime` (updates atime only if older than mtime, default in many distros)\n\n**`subvol=@`**:\n- Specifies which subvolume to mount\n- Mount the `@` subvolume (our root filesystem)\n- Without this, you'd mount the Btrfs root container\n\n**`/dev/sda3`**: The device containing the Btrfs filesystem\n\n**`/mnt`**: Mount point (where the filesystem appears)\n\n#### Create Mount Point Directories\n```{bash}\n#| eval: false\nmkdir -p /mnt/{boot/efi,home,var/cache/pacman/pkg}\n```\n\n**What this does:**\n\n- `mkdir -p`: Creates directories, including parents (no error if exists)\n- Creates the directory structure in one command using brace expansion\n- Expands to:\n```bash\n  mkdir -p /mnt/boot/efi\n  mkdir -p /mnt/home\n  mkdir -p /mnt/var/cache/pacman/pkg\n```\n\n**Why this is crucial:**\n\n- Mount points must exist before mounting\n- Forgetting this is a common installation error\n- Without these directories, subsequent mounts will fail\n- The `/boot/efi` structure (nested) needs `-p` to create parents\n\n#### Mount Home Subvolume\n```{bash}\n#| eval: false\nmount -o compress=zstd,noatime,subvol=@home /dev/sda3 /mnt/home\n```\n\n**What this does:**\n\n- Mounts the `@home` subvolume to `/mnt/home`\n- Uses the same optimization options as root\n- User data will be stored here: `/home/username/`\n\n**Note on subvolume naming:**\n\nIf you created the subvolume as `@home`, use `subvol=@home`. In the original document, the subvolume was actually created as `home` (without `@`), so the mount command used `subvol=home`. Make sure your mount option matches your actual subvolume name.\n\nTo check:\n```{bash}\n#| eval: false\nbtrfs subvolume list /dev/sda3\n```\n\n#### Mount Package Cache Subvolume\n```{bash}\n#| eval: false\nmount -o compress=zstd,noatime,subvol=@pkg /dev/sda3 /mnt/var/cache/pacman/pkg\n```\n\n**What this does:**\n\n- Mounts `@pkg` subvolume to the pacman cache directory\n- Separates package downloads from system and user data\n\n**Why separate the package cache?**\n\n- **Snapshots**: Exclude large package files from system snapshots\n- **Cleanup**: Can delete the entire subvolume without affecting the system\n- **Space**: Package cache can grow to several GB over time\n- **Sharing**: Multiple snapshots can share one package cache\n\n**About pacman cache:**\n\n- Pacman stores downloaded packages here before installation\n- Allows downgrading or reinstalling without redownloading\n- Can be cleared with `pacman -Sc` (remove uninstalled packages)\n- Or `pacman -Scc` (remove all cached packages)\n\n#### Mount EFI Partition\n```{bash}\n#| eval: false\nmount /dev/sda1 /mnt/boot/efi\n```\n\n**What this does:**\n\n- Mounts the FAT32 EFI partition to `/mnt/boot/efi`\n- No special options needed (FAT32 doesn't support them anyway)\n- This is where GRUB will install its `.efi` files\n\n**Alternative mount points:**\n\n- Some guides use `/mnt/boot` directly\n- We use `/mnt/boot/efi` (a subdirectory)\n- This allows `/boot` itself to be on Btrfs\n- Keeps kernel images in the snapshot-able root subvolume\n\n#### Verify the Complete Mount Structure\n```{bash}\n#| eval: false\nlsblk\n```\n\n**Expected output:**\n```\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0   20G  0 disk \n├─sda1   8:1    0  512M  0 part /mnt/boot/efi\n├─sda2   8:2    0    2G  0 part [SWAP]\n└─sda3   8:3    0 17.5G  0 part /mnt\n                                 /mnt/home\n                                 /mnt/var/cache/pacman/pkg\n```\n\n**What to verify:**\n\n- `/dev/sda1` mounted at `/mnt/boot/efi`\n- `/dev/sda2` marked as `[SWAP]`\n- `/dev/sda3` mounted three times (three subvolumes)\n\n**Detailed mount information:**\n```{bash}\n#| eval: false\nmount | grep /mnt\n```\n\nShould show:\n```\n/dev/sda3 on /mnt type btrfs (rw,noatime,compress=zstd:3,space_cache,subvol=/@)\n/dev/sda3 on /mnt/home type btrfs (rw,noatime,compress=zstd:3,space_cache,subvol=/@home)\n/dev/sda3 on /mnt/var/cache/pacman/pkg type btrfs (rw,noatime,compress=zstd:3,space_cache,subvol=/@pkg)\n/dev/sda1 on /mnt/boot/efi type vfat (rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro)\n```\n\n## Phase 3: Installing the Base System\n\n### Understanding Package Mirrors\n\nArch Linux packages are distributed via mirrors worldwide. Faster mirrors mean faster installation and updates.\n\n#### Step 3.1: Select Mirrors (Optional but Recommended)\n```{bash}\n#| eval: false\nvim /etc/pacman.d/mirrorlist\n```\n\n**What this file contains:**\n\nA long list of mirror URLs, formatted like:\n```\n## Germany\n#Server = https://arch.mirror.konstant.no/$repo/os/$arch\nServer = https://ftp.fau.de/archlinux/$repo/os/$arch\n#Server = https://mirror.f4st.host/archlinux/$repo/os/$arch\n```\n\n**Understanding the format:**\n\n- Lines starting with `#` are comments (disabled)\n- `Server =` lines are active mirrors\n- `$repo`: Replaced with repository name (core, extra, community)\n- `$arch`: Replaced with architecture (x86_64)\n\n**How to optimize:**\n\n1. Find mirrors in your country (look for `## Germany` or your region)\n2. Move fast mirrors to the top (pacman tries mirrors in order)\n3. Uncomment (`#` remove) fast mirrors if needed\n4. Leave at least 5-6 mirrors (redundancy if one is down)\n\n**vim quick reference for this task:**\n\n- `/Germany` - Search for \"Germany\"\n- `dd` - Delete (cut) current line\n- `gg` - Go to top of file\n- `p` - Paste below current line\n- `:wq` - Write and quit\n\n**Alternative method (automatic):**\n```{bash}\n#| eval: false\nreflector --country Germany --age 12 --protocol https --sort rate --save /etc/pacman.d/mirrorlist\n```\n\nThis requires `reflector` package (available in live environment).\n\n### Step 3.2: Install Base Packages\n\nThis is the core installation step that creates your Arch Linux system.\n```{bash}\n#| eval: false\npacstrap /mnt base linux linux-firmware vim\n```\n\n**What this does:**\n\n- `pacstrap`: Arch installation script that sets up base system\n- `/mnt`: Target directory (our mounted root filesystem)\n- Package list: `base linux linux-firmware vim`\n\n**Breaking down each package:**\n\n**`base`**:\n- Meta-package containing essential system utilities\n- Includes: `bash`, `coreutils`, `systemd`, `glibc`\n- Provides: basic commands (`ls`, `cp`, `mkdir`), init system, C library\n- This is the minimal foundation of an Arch system\n\n**`linux`**:\n- The Linux kernel package\n- Contains: kernel binary, modules (drivers)\n- Alternatives: `linux-lts` (Long Term Support), `linux-zen` (optimized), `linux-hardened`\n- The kernel is the core of the operating system\n\n**`linux-firmware`**:\n- Binary firmware blobs for hardware\n- Contains: Wi-Fi firmware, GPU firmware, etc.\n- Required for most hardware to function\n- Can be omitted in VMs (no real hardware), but small size makes it harmless\n\n**`vim`**:\n- Text editor (Vi IMproved)\n- Needed for editing configuration files post-installation\n- Alternatives: `nano` (easier for beginners), `emacs`, `neovim`\n\n**What happens during installation:**\n\n1. Downloads packages from mirrors (~400MB total)\n2. Extracts packages to `/mnt`\n3. Configures basic system structure\n4. Sets up pacman (package manager) database\n\n**Time estimate:** 5-15 minutes depending on mirror speed\n\n**Common issues:**\n\n- **\"failed to retrieve\"**: Mirror is down, pacman tries next mirror\n- **\"insufficient disk space\"**: Check partition sizes with `df -h /mnt`\n- **\"signature is unknown trust\"**: System time is wrong, run `timedatectl set-ntp true`\n\n### Step 3.3: Generate fstab\n\nThe fstab (file systems table) file tells the system what to mount at boot.\n```{bash}\n#| eval: false\ngenfstab -U /mnt >> /mnt/etc/fstab\n```\n\n**What this does:**\n\n- `genfstab`: Generates fstab entries from currently mounted filesystems\n- `-U`: Use UUIDs instead of device names\n- `/mnt`: Scan this mount point and its children\n- `>>`: Append output to the file (don't overwrite)\n\n**Why UUIDs?**\n\n**Device names (`/dev/sda1`) can change:**\n- Adding/removing disks\n- Different boot order\n- Hotplugging USB devices\n\n**UUIDs are permanent:**\n- Universally Unique Identifier\n- Assigned when filesystem is formatted\n- Never changes (unless you reformat)\n- Example: `UUID=a1b2c3d4-e5f6-7890-abcd-ef1234567890`\n\n**Verify the generated fstab:**\n```{bash}\n#| eval: false\ncat /mnt/etc/fstab\n```\n\n**Expected content:**\n```\n# /dev/sda3 LABEL=ArchRoot\nUUID=<uuid>  /  btrfs  rw,noatime,compress=zstd:3,space_cache,subvol=/@  0 0\n\n# /dev/sda3 LABEL=ArchRoot\nUUID=<uuid>  /home  btrfs  rw,noatime,compress=zstd:3,space_cache,subvol=/@home  0 0\n\n# /dev/sda3 LABEL=ArchRoot\nUUID=<uuid>  /var/cache/pacman/pkg  btrfs  rw,noatime,compress=zstd:3,space_cache,subvol=/@pkg  0 0\n\n# /dev/sda1\nUUID=<uuid>  /boot/efi  vfat  rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro  0 2\n\n# /dev/sda2\nUUID=<uuid>  none  swap  defaults  0 0\n```\n\n**Understanding fstab columns:**\n\n1. **Device**: UUID or device path\n2. **Mount point**: Where to mount\n3. **Type**: Filesystem type (`btrfs`, `vfat`, `swap`)\n4. **Options**: Mount options (same as `-o` in mount command)\n5. **Dump**: Backup frequency (0 = never, used by `dump` tool)\n6. **Pass**: fsck order (0 = skip, 1 = root first, 2 = others)\n\n**Important notes:**\n\n- Btrfs subvolumes all have the same UUID (same physical partition)\n- They're differentiated by `subvol=` option\n- Swap has `none` as mount point (not mounted, just activated)\n\n## Phase 4: Configure the New System\n\n### Understanding chroot\n\nChroot (change root) allows you to work inside the new system before booting it.\n```{bash}\n#| eval: false\narch-chroot /mnt\n```\n\n**What this does:**\n\n- Changes the apparent root directory to `/mnt`\n- Inside chroot, `/` is actually `/mnt` from the outside\n- You're now \"inside\" the installed system\n- Your prompt should change to `[root@archiso /]#`\n\n**Why use chroot:**\n\n- Configure system files in their final locations\n- Install additional packages using the new system's pacman\n- Set up users, hostname, bootloader\n- Test the environment before rebooting\n\n**What chroot does NOT do:**\n\n- Doesn't boot the kernel (still running live environment kernel)\n- Doesn't start systemd services\n- Network is shared with live environment\n- Some operations (kernel modules) affect live environment\n\n**Note:** All subsequent commands in Phase 4 run inside the chroot.\n\n### Step 4.1: Configure Time Zone\n\nTime zone configuration determines how your system displays time.\n```{bash}\n#| eval: false\nln -sf /usr/share/zoneinfo/Europe/Berlin /etc/localtime\n```\n\n**What this does:**\n\n- `ln -sf`: Creates a symbolic link, force overwrite if exists\n- Source: `/usr/share/zoneinfo/Europe/Berlin` (time zone data file)\n- Target: `/etc/localtime` (system time zone configuration)\n\n**Finding your time zone:**\n```{bash}\n#| eval: false\nls /usr/share/zoneinfo/\n```\n\nBrowse continents, then:\n```{bash}\n#| eval: false\nls /usr/share/zoneinfo/Europe/\n```\n\nCommon zones:\n\n- `Europe/Berlin` - Germany, most of Western Europe\n- `America/New_York` - US Eastern Time\n- `America/Los_Angeles` - US Pacific Time\n- `Asia/Tokyo` - Japan\n- `UTC` - Coordinated Universal Time (no daylight saving)\n\n**Sync hardware clock:**\n```{bash}\n#| eval: false\nhwclock --systohc\n```\n\n**What this does:**\n\n- `--systohc`: Set hardware clock from system time\n- Hardware clock: Battery-powered clock in motherboard\n- System clock: Software clock maintained by kernel\n- This writes current system time to CMOS/UEFI variables\n\n**Why this matters:**\n\n- Hardware clock persists across reboots\n- On boot, system clock initializes from hardware clock\n- Keeps time accurate even when system is off\n- Assumes hardware clock is in UTC (modern standard)\n\n### Step 4.2: Localization (Generate Locales)\n\nLocales determine language, character encoding, date/time formats, currency, etc.\n\n#### Edit locale.gen\n```{bash}\n#| eval: false\nvim /etc/locale.gen\n```\n\n**What this file contains:**\n\nA list of all possible locales, all commented out (disabled):\n#de_DE.UTF-8 UTF-8\n#de_DE ISO-8859-1\n#de_DE@euro ISO-8859-15\n#en_US.UTF-8 UTF-8\n#en_US ISO-8859-1\n\n**What to do:**\n\nUncomment (remove `#`) from the locales you need.\n\n**Recommended:** Always uncomment `en_US.UTF-8 UTF-8` for:\n\n- Most software assumes US English is available\n- Error messages and documentation are typically in English\n- Many programs default to this locale\n\n**Additionally uncomment your native locale if different:**\n\n- `de_DE.UTF-8 UTF-8` for German\n- `fr_FR.UTF-8 UTF-8` for French\n- `es_ES.UTF-8 UTF-8` for Spanish\n- `ja_JP.UTF-8 UTF-8` for Japanese\n\n**Understanding locale format:**\n\n- `en_US`: Language code (`en`) + Country code (`US`)\n- `UTF-8`: Character encoding (supports all Unicode characters)\n- Alternative encodings like `ISO-8859-1` are legacy (avoid unless needed)\n\n**Why UTF-8?**\n\n- Supports all languages and special characters\n- Modern standard for text encoding\n- Compatible with ASCII (first 128 characters identical)\n- Required for proper display of international text\n\n**vim quick reference:**\n\n- `/en_US.UTF-8` - Search for the locale\n- `0` - Move to beginning of line\n- `x` - Delete the `#` character\n- `:wq` - Write and quit\n\n#### Generate the Locales\n```{bash}\n#| eval: false\nlocale-gen\n```\n\n**What this does:**\n\n- Reads `/etc/locale.gen`\n- Compiles all uncommented locales\n- Creates binary locale data in `/usr/lib/locale/`\n- Generates locale archive for fast loading\n\n**Expected output:**\n```\nGenerating locales...\n  en_US.UTF-8... done\n  de_DE.UTF-8... done\nGeneration complete.\n```\n\n**What locales affect:**\n\n- Language of system messages\n- Date/time format (MM/DD/YYYY vs DD.MM.YYYY)\n- Number format (1,234.56 vs 1.234,56)\n- Currency symbols ($ vs €)\n- Paper size (Letter vs A4)\n- Sorting order (collation)\n\n#### Set System Locale\n```{bash}\n#| eval: false\necho \"LANG=en_US.UTF-8\" > /etc/locale.conf\n```\n\n**What this does:**\n\n- Creates `/etc/locale.conf` with the system default locale\n- `LANG` variable sets the fallback for all locale categories\n- This affects system messages, date formats, etc.\n\n**Why en_US.UTF-8 even if you're not in the US?**\n\n- **Error messages**: Most documentation and forum help is in English\n- **Troubleshooting**: Easier to search for English error messages\n- **Consistency**: Many programs expect English locale\n- **Compatibility**: Some software has poor translations\n\n**Alternative approach (use native language):**\n```{bash}\n#| eval: false\necho \"LANG=de_DE.UTF-8\" > /etc/locale.conf\n```\n\nThis makes German the system language.\n\n**Advanced: Per-category settings:**\n\nYou can mix languages for different aspects:\n```bash\nLANG=en_US.UTF-8\nLC_TIME=de_DE.UTF-8\nLC_MONETARY=de_DE.UTF-8\n```\n\nThis gives English messages but German date/currency formats.\n\n**Verify locale settings:**\n```{bash}\n#| eval: false\nlocale\n```\n\nShows all locale categories and their current values.\n\n### Step 4.3: Keyboard Layout (Console)\n\nThis sets the keyboard layout for the virtual console (TTY), not the X server.\n```{bash}\n#| eval: false\necho \"KEYMAP=de-latin1\" > /etc/vconsole.conf\n```\n\n**What this does:**\n\n- Creates `/etc/vconsole.conf`\n- Sets `KEYMAP` to `de-latin1` (German QWERTZ)\n- Applied at boot before any graphical environment\n\n**Why this is needed:**\n\n- Live environment uses US QWERTY by default\n- Without this, you'll have wrong layout after reboot\n- Especially important for entering passwords at boot\n\n**Common keymaps:**\n\n- `us` - US QWERTY (default)\n- `de-latin1` or `de` - German QWERTZ\n- `uk` - UK QWERTY\n- `fr-latin1` - French AZERTY\n- `es` - Spanish\n\n**Finding available keymaps:**\n```{bash}\n#| eval: false\nlocalectl list-keymaps | grep de\n```\n\nShows all German keyboard variants:\n```\nde\nde-latin1\nde-latin1-nodeadkeys\nde_CH-latin1\nde_alt_UTF-8\n```\n\n**Differences:**\n\n- `de-latin1`: Standard German with dead keys (for umlauts: ä, ö, ü)\n- `de-latin1-nodeadkeys`: No dead keys (direct character input)\n- `de_CH-latin1`: Swiss German\n\n**Note about graphical environments:**\n\nThis only affects the console (Ctrl+Alt+F2, boot messages, emergency mode). Desktop environments like GNOME/KDE have their own keyboard settings configured separately.\n\n**Test keymap immediately (before reboot):**\n```{bash}\n#| eval: false\nloadkeys de-latin1\n```\n\nType some characters to verify the layout is correct.\n\n### Step 4.4: Network Configuration\n\nProper network setup ensures you can connect to the internet after reboot.\n\n#### Set Hostname\n```{bash}\n#| eval: false\necho \"arch-vm-config\" > /etc/hostname\n```\n\n**What this does:**\n\n- Creates `/etc/hostname` with your chosen hostname\n- Hostname: Human-readable name identifying this machine\n- Used in network communications, shell prompt, logs\n\n**Hostname guidelines:**\n\n- Only lowercase letters, numbers, and hyphens\n- No spaces or special characters\n- Should be descriptive but concise\n- Examples: `arch-desktop`, `myarch`, `workstation`, `arch-vm`\n\n**Why it matters:**\n\n- Identifies your machine on networks\n- Appears in router/DHCP listings\n- Used in Samba/network shares\n- Shows in terminal prompts\n\n**Verify hostname:**\n```{bash}\n#| eval: false\ncat /etc/hostname\n```\n\n#### Install NetworkManager\n```{bash}\n#| eval: false\npacman -S networkmanager\n```\n\n**What this does:**\n\n- Installs NetworkManager package\n- NetworkManager: High-level network configuration tool\n- Manages Ethernet, Wi-Fi, VPN, mobile broadband\n\n**Why NetworkManager?**\n\n**Alternatives exist:**\n\n- `systemd-networkd`: Simpler, built into systemd\n- `netctl`: Arch-specific, profile-based\n- `dhcpcd`: Minimal, DHCP client only\n\n**NetworkManager advantages:**\n\n- Works with desktop environments (GNOME, KDE, Xfce)\n- Has GUI tools (`nm-applet`, `nm-connection-editor`)\n- Handles complex scenarios (VPN, multiple networks)\n- Automatic connection management\n- Wi-Fi support with GUI password prompts\n\n**Components installed:**\n\n- `NetworkManager`: Core daemon\n- `nmcli`: Command-line interface\n- Libraries for desktop environment integration\n\n**During installation:**\n```\nresolving dependencies...\nlooking for conflicting packages...\n\nPackages (X) NetworkManager-1.44.2-3 ...\n\nTotal Download Size:    X.XX MiB\nTotal Installed Size:   X.XX MiB\n\n:: Proceed with installation? [Y/n]\n```\n\nPress Enter or type `y`.\n\n#### Enable NetworkManager Service\n```{bash}\n#| eval: false\nsystemctl enable NetworkManager\n```\n\n**What this does:**\n\n- Creates a symbolic link in systemd configuration\n- NetworkManager will start automatically at boot\n- Without this, you'll have no network after reboot\n\n**Understanding systemd services:**\n\n- Services are background processes (daemons)\n- Systemd manages service lifecycle (start, stop, restart)\n- `enable`: Service starts at boot\n- `start`: Service starts now (but we can't fully start in chroot)\n\n**Expected output:**\n```\nCreated symlink /etc/systemd/system/multi-user.target.wants/NetworkManager.service → /usr/lib/systemd/system/NetworkManager.service.\nCreated symlink /etc/systemd/system/dbus-org.freedesktop.nm-dispatcher.service → /usr/lib/systemd/system/NetworkManager-dispatcher.service.\nCreated symlink /etc/systemd/system/network-online.target.wants/NetworkManager-wait-online.service → /usr/lib/systemd/system/NetworkManager-wait-online.service.\n```\n\n**What these symlinks mean:**\n\n- `multi-user.target.wants`: Start when reaching multi-user runlevel\n- `dbus...`: Enable D-Bus integration for event handling\n- `network-online.target`: Ensures network is up before dependent services\n\n**Verify service is enabled:**\n```{bash}\n#| eval: false\nsystemctl is-enabled NetworkManager\n```\n\nShould output: `enabled`\n\n**Common mistake:**\n\n- Service name is `NetworkManager` (capital N, capital M)\n- Not `networkmanager` or `network-manager`\n- Linux service names are case-sensitive\n\n### Step 4.5: Set Root Password\n\nThe root account has unlimited system privileges. Securing it is critical.\n```{bash}\n#| eval: false\npasswd\n```\n\n**What this does:**\n\n- Sets password for the current user (root, since we're in chroot as root)\n- Prompts you twice to ensure accuracy\n- Hashes and stores password in `/etc/shadow`\n\n**Password prompt:**\n```\nNew password: \nRetype new password: \npasswd: password updated successfully\n```\n\n**Password best practices:**\n\n- **Length**: Minimum 12 characters (longer is better)\n- **Complexity**: Mix uppercase, lowercase, numbers, symbols\n- **Uniqueness**: Don't reuse passwords from other accounts\n- **Memorability**: Use a passphrase (e.g., \"correct-horse-battery-staple\")\n\n**Password strength examples:**\n\n- ❌ Weak: `password123`, `admin`, `12345678`\n- ⚠️ Fair: `MyArch2024!`\n- ✅ Strong: `Tr0ub4dor&3` or `correct-horse-battery-staple`\n\n**Why set root password?**\n\n- **Emergency access**: If sudo breaks, you can log in as root\n- **System maintenance**: Some tasks require root login\n- **Security**: Prevents unauthorized root access\n\n**Important security note:**\n\nYou'll create a regular user account next. For daily use, you should:\n\n- **Always** use your regular account\n- **Never** log in as root for routine tasks\n- Use `sudo` for administrative commands\n- Root account is for emergencies and system recovery\n\n### Step 4.6: Create User Account and Configure sudo\n\nRunning as root constantly is dangerous. A regular user account with sudo access is the secure approach.\n\n#### Create User Account\n```{bash}\n#| eval: false\nuseradd -mG wheel -s /bin/bash myusername\n```\n\n**Replace `myusername` with your actual desired username.**\n\n**Breaking down the options:**\n\n**`-m`**: Create home directory\n\n- Creates `/home/myusername/`\n- Populates it with skeleton files from `/etc/skel/`\n- Without `-m`, user has no home directory\n\n**`-G wheel`**: Add user to supplementary group\n\n- `wheel`: Traditional Unix group for users with sudo access\n- Group membership determines privileges\n- User can belong to multiple groups\n\n**`-s /bin/bash`**: Set login shell\n\n- Shell: Command interpreter user interacts with\n- `/bin/bash`: Bourne Again Shell (most common)\n- Alternatives: `/bin/zsh`, `/bin/fish`, `/bin/sh`\n\n**Username guidelines:**\n\n- Lowercase letters only (convention)\n- Can include numbers and underscores\n- No spaces or special characters\n- Examples: `john`, `alice`, `admin`, `myuser`\n\n**What gets created:**\n\n- Entry in `/etc/passwd` (user database)\n- Entry in `/etc/shadow` (password hashes)\n- Entry in `/etc/group` (group memberships)\n- Home directory at `/home/myusername/`\n\n**Verify user creation:**\n```{bash}\n#| eval: false\nid myusername\n```\n\nExpected output:\n```\nuid=1000(myusername) gid=1000(myusername) groups=1000(myusername),998(wheel)\n```\n\n**Understanding the output:**\n\n- `uid=1000`: User ID (first regular user gets 1000)\n- `gid=1000`: Primary group ID\n- `groups=...`: All group memberships (including `wheel`)\n\n#### Set User Password\n```{bash}\n#| eval: false\npasswd myusername\n```\n\n**What this does:**\n\n- Sets password for the specified user\n- Same process as setting root password\n- This password is used to log in as this user\n\n**Password considerations:**\n\n- Can be different from root password (recommended)\n- Should still be strong (this is your daily account)\n- You'll type this frequently, so balance security and convenience\n- Consider using a password manager\n\n#### Install sudo\n```{bash}\n#| eval: false\npacman -S sudo\n```\n\n**What sudo does:**\n\n- `sudo`: \"Superuser do\" - execute commands as root\n- Allows temporary privilege elevation\n- Logs all sudo commands (accountability)\n- Prompts for user's password (not root password)\n\n**Why sudo is essential:**\n\n- **Security**: Don't run as root constantly\n- **Auditing**: Logs who did what and when\n- **Flexibility**: Per-command privilege escalation\n- **Best practice**: Standard in modern Linux systems\n\n**Installation output:**\n```\nresolving dependencies...\nlooking for conflicting packages...\n\nPackages (1) sudo-1.9.x-x\n\nTotal Download Size:    X.XX MiB\nTotal Installed Size:   X.XX MiB\n\n:: Proceed with installation? [Y/n]\n```\n\n#### Configure sudo for wheel Group\n```{bash}\n#| eval: false\nvisudo\n```\n\n**What this does:**\n\n- Opens `/etc/sudoers` in a safe editor\n- `visudo`: Checks syntax before saving (prevents lockout)\n- Never edit `/etc/sudoers` directly with vim/nano\n\n**Why visudo is important:**\n\n- Syntax errors in `/etc/sudoers` can lock you out\n- `visudo` validates configuration before saving\n- Uses `vi` by default (vim in Arch)\n- Prevents simultaneous editing\n\n**What to find and edit:**\n\nLook for this line (around line 85):\n```\n# %wheel ALL=(ALL:ALL) ALL\n```\n\n**Uncomment it (remove the `#`):**\n```\n%wheel ALL=(ALL:ALL) ALL\n```\n\n**Understanding this line:**\n\n- `%wheel`: Applies to members of the \"wheel\" group (% indicates group)\n- First `ALL`: Rule applies on all hosts\n- `(ALL:ALL)`: Can run as any user and any group\n- Last `ALL`: Can run all commands\n\n**Translation:** \"Members of wheel group can run any command as any user on any host.\"\n\n**Alternative configurations available:**\n```\n# %wheel ALL=(ALL:ALL) NOPASSWD: ALL\n```\n\nUncomment this instead if you want sudo without password (less secure, convenient for VMs).\n\n**Save and exit:**\n\n- In vim: Press `Esc`, type `:wq`, press Enter\n- visudo will check syntax and save\n\n**Verify sudo configuration:**\n\nAfter creating your user, test (later after reboot):\n```{bash}\n#| eval: false\nsudo -l\n```\n\nShould show what you can run with sudo.\n\n### Step 4.7: Install and Configure Bootloader (GRUB)\n\nThe bootloader is the first software that runs when you turn on the computer. It loads the Linux kernel.\n\n#### Install GRUB Packages\n```{bash}\n#| eval: false\npacman -S grub efibootmgr\n```\n\n**Package breakdown:**\n\n**`grub`**:\n- **GR**and **U**nified **B**ootloader\n- Most popular bootloader for Linux\n- Supports UEFI and BIOS\n- Handles multi-boot (Windows + Linux)\n- Highly configurable\n\n**`efibootmgr`**:\n- Manages UEFI boot entries\n- Required for UEFI systems\n- Modifies NVRAM boot order\n- Creates boot entries visible in BIOS/UEFI\n\n**Why GRUB?**\n\n**Alternatives exist:**\n\n- `systemd-boot`: Simpler, UEFI-only\n- `rEFInd`: Graphical, multi-OS focus\n- `LILO`: Legacy, rarely used now\n\n**GRUB advantages:**\n\n- Mature, well-documented\n- Extensive configuration options\n- Theme support\n- Works everywhere (UEFI and BIOS)\n- Large community support\n\n#### Install GRUB to EFI Partition\n```{bash}\n#| eval: false\ngrub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB\n```\n\n**Breaking down each option:**\n\n**`--target=x86_64-efi`**:\n- Specifies the platform architecture\n- `x86_64`: 64-bit x86 processor\n- `efi`: UEFI firmware (not BIOS)\n- Determines which GRUB binary to use\n\n**`--efi-directory=/boot/efi`**:\n- Location of the EFI System Partition mount\n- Where GRUB will install its `.efi` files\n- Must match where you mounted `/dev/sda1`\n\n**`--bootloader-id=GRUB`**:\n- Name for this bootloader in UEFI menu\n- Creates `/boot/efi/EFI/GRUB/` directory\n- Shows up as \"GRUB\" in BIOS boot selection\n\n**What this command does:**\n\n1. Copies GRUB files to `/boot/efi/EFI/GRUB/`\n2. Creates `grubx64.efi` (the actual bootloader)\n3. Registers boot entry in UEFI firmware\n4. Sets up fallback boot path\n\n**Expected output:**\n```\nInstalling for x86_64-efi platform.\nInstallation finished. No error reported.\n```\n\n**Verify installation:**\n```{bash}\n#| eval: false\nls /boot/efi/EFI/GRUB/\n```\n\nShould show:\n```\ngrubx64.efi  grub.cfg  ...\n```\n\n**Check UEFI boot entries:**\n```{bash}\n#| eval: false\nefibootmgr\n```\n\nExpected output:\n```\nBootCurrent: 0001\nTimeout: 1 seconds\nBootOrder: 0000,0001\nBoot0000* GRUB\nBoot0001* UEFI OS\n```\n\n- `Boot0000* GRUB`: Your new GRUB entry\n- `BootOrder`: Boot sequence (GRUB is first)\n\n#### Generate GRUB Configuration\n```{bash}\n#| eval: false\ngrub-mkconfig -o /boot/grub/grub.cfg\n```\n\n**What this does:**\n\n- Scans for installed operating systems\n- Detects installed kernels\n- Creates `/boot/grub/grub.cfg` (GRUB menu configuration)\n- Reads settings from `/etc/default/grub`\n\n**Expected output:**\n```\nGenerating grub configuration file ...\nFound linux image: /boot/vmlinuz-linux\nFound initrd image: /boot/initramfs-linux.img\nFound fallback initrd image: /boot/initramfs-linux-fallback.img\ndone\n```\n\n**Understanding the output:**\n\n**`vmlinuz-linux`**:\n- The Linux kernel itself\n- Compressed kernel image\n- This is what GRUB loads into memory\n\n**`initramfs-linux.img`**:\n- Initial RAM filesystem\n- Contains drivers needed to mount real root filesystem\n- Loaded before actual root is mounted\n\n**`initramfs-linux-fallback.img`**:\n- Fallback initramfs with all possible drivers\n- Used if regular initramfs fails to boot\n- Larger but more compatible\n\n**The generated configuration:**\n```{bash}\n#| eval: false\ncat /boot/grub/grub.cfg\n```\n\nShows auto-generated menu entries:\n```\nmenuentry 'Arch Linux' --class arch --class gnu-linux ... {\n    load_video\n    set gfxpayload=keep\n    insmod gzio\n    insmod part_gpt\n    insmod btrfs\n    search --no-floppy --fs-uuid --set=root <uuid>\n    echo 'Loading Linux linux ...'\n    linux /@/boot/vmlinuz-linux root=UUID=<uuid> rw rootflags=subvol=@ ...\n    echo 'Loading initial ramdisk ...'\n    initrd /@/boot/initramfs-linux.img\n}\n```\n\n**Key elements:**\n\n- `search`: Finds root partition by UUID\n- `linux`: Loads kernel with root location and options\n- `rootflags=subvol=@`: Tells kernel to mount `@` subvolume as root\n- `initrd`: Loads initial RAM disk\n\n**Customizing GRUB (optional):**\n\nEdit `/etc/default/grub`:\n```{bash}\n#| eval: false\nvim /etc/default/grub\n```\n\nUseful settings:\n```bash\nGRUB_TIMEOUT=5                    # Time before auto-boot (seconds)\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\"  # Kernel parameters\nGRUB_GFXMODE=1920x1080x32        # Resolution\n```\n\nAfter editing, regenerate config:\n```{bash}\n#| eval: false\ngrub-mkconfig -o /boot/grub/grub.cfg\n```\n\n### Step 4.8: Install VMware Tools\n\nThese tools improve integration between host and guest VM.\n```{bash}\n#| eval: false\npacman -S open-vm-tools\n```\n\n**What open-vm-tools provides:**\n\n**Core functionality:**\n\n- **Shared clipboard**: Copy/paste between host and VM\n- **Drag and drop**: Files between host and VM\n- **Shared folders**: Access host directories from VM\n- **Time synchronization**: Keep VM time accurate\n- **Display resolution**: Auto-adjust to window size\n\n**Additional features:**\n\n- **Memory ballooning**: Dynamic memory allocation\n- **Snapshots**: Better quiescing for VM snapshots\n- **Guest info**: Reports VM state to host\n- **Unity mode**: Seamless window integration (on some hosts)\n\n**Why open-vm-tools?**\n\n- Open-source alternative to VMware Tools\n- Maintained by VMware\n- Included in Linux kernel\n- Better integration with modern systems\n- No need to install from VMware ISO\n\n#### Enable VMtools Service\n```{bash}\n#| eval: false\nsystemctl enable vmtoolsd.service\n```\n\n**What this does:**\n\n- Enables the VMware Tools daemon to start at boot\n- Daemon runs in background providing host integration\n- Without this, features won't work after reboot\n\n**Expected output:**\n```\nCreated symlink /etc/systemd/system/multi-user.target.wants/vmtoolsd.service → /usr/lib/systemd/system/vmtoolsd.service.\n```\n\n**Additional services (optional):**\n```{bash}\n#| eval: false\nsystemctl enable vmware-vmblock-fuse.service  # For drag-and-drop\n```\n\n**Verify after reboot:**\n```{bash}\n#| eval: false\nsystemctl status vmtoolsd\n```\n\nShould show `active (running)`.\n\n**Test functionality:**\n\n- Resize VM window - desktop should auto-resize\n- Copy text in host - paste in VM\n- Check time sync: `timedatectl`\n\n## Phase 5: Finalize and Reboot\n\n### Step 5.1: Exit Chroot\n```{bash}\n#| eval: false\nexit\n```\n\n**What this does:**\n\n- Exits the chroot environment\n- Returns to the live environment\n- Prompt changes back to `root@archiso ~ #`\n\n**You're now \"outside\" the installed system again.**\n\n### Step 5.2: Unmount All Partitions\n```{bash}\n#| eval: false\numount -R /mnt\n```\n\n**What this does:**\n\n- `-R`: Recursive unmount\n- Unmounts `/mnt` and all mountpoints under it\n- Ensures all data is written to disk (flushes buffers)\n\n**Why this is important:**\n\n- Pending writes are flushed to disk\n- Prevents data corruption\n- Clean shutdown of filesystems\n- Btrfs metadata is finalized\n\n**What gets unmounted:**\n\n1. `/mnt/boot/efi` (EFI partition)\n2. `/mnt/home` (home subvolume)\n3. `/mnt/var/cache/pacman/pkg` (package cache subvolume)\n4. `/mnt` (root subvolume)\n\n**If unmount fails:**\n```{bash}\n#| eval: false\nlsof +D /mnt  # See what's using /mnt\nfuser -km /mnt  # Kill processes using /mnt (careful!)\numount -R /mnt  # Try again\n```\n\n**Verify everything is unmounted:**\n```{bash}\n#| eval: false\nlsblk\n```\n\nShould show no mountpoints under `/mnt`:\n```\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0   20G  0 disk \n├─sda1   8:1    0  512M  0 part \n├─sda2   8:2    0    2G  0 part [SWAP]\n└─sda3   8:3    0 17.5G  0 part \n```\n\n### Step 5.3: Reboot into New System\n```{bash}\n#| eval: false\nreboot\n```\n\n**What happens:**\n\n1. System initiates shutdown sequence\n2. All remaining filesystems unmounted\n3. Swap deactivated\n4. VM reboots\n5. **CRITICAL**: GRUB should load from disk\n\n**🔥 IMPORTANT: Remove Installation Media**\n\n**Immediately after typing `reboot`:**\n\n1. Go to VMware menu: VM → Settings\n2. Select CD/DVD (SATA)\n3. Uncheck \"Connect at power on\"\n4. Or change to \"Use physical drive\"\n5. Click OK\n\n**If you forget:**\n\n- VM will boot the Arch ISO again (live environment)\n- You'll be back at the installation environment\n- Simply remove the ISO and reboot again\n\n**First boot sequence:**\n\n1. VMware UEFI firmware initializes\n2. GRUB loads from `/boot/efi/EFI/GRUB/grubx64.efi`\n3. GRUB menu appears (5-second timeout)\n4. Kernel loads with initramfs\n5. Systemd starts as init (PID 1)\n6. Services start (NetworkManager, etc.)\n7. Getty starts on TTY1 (login prompt)\n\n**Expected login prompt:**\n```\nArch Linux 6.x.x-arch1-1 (tty1)\n\narch-vm-config login: _\n```\n\n**Login as your user:**\n\n- Username: Your created username\n- Password: User password you set\n\n**First commands to run:**\n```{bash}\n#| eval: false\n# Check network\nip addr show\nping archlinux.org\n\n# Update system\nsudo pacman -Syu\n\n# Check disk usage\ndf -h\n\n# View mounted subvolumes\nmount | grep btrfs\n```\n\n## Post-Installation: Understanding Your System\n\n### What You've Built\n\nYou now have:\n\n1. **UEFI-bootable system**: Modern boot process with GRUB\n2. **Btrfs filesystem**: With subvolumes for flexibility\n3. **Minimal base**: Only essential packages installed\n4. **User account**: With sudo privileges\n5. **Network**: Configured and automatic\n6. **VM integration**: Open-vm-tools for host integration\n\n### System Architecture Overview\n```\nHardware (VMware VM)\n    ↓\nUEFI Firmware\n    ↓\nGRUB Bootloader (/boot/efi/EFI/GRUB/grubx64.efi)\n    ↓\nLinux Kernel (/boot/vmlinuz-linux)\n    ↓\nInitramfs (/boot/initramfs-linux.img)\n    ↓\nSystemd (PID 1)\n    ↓\nSystem Services (NetworkManager, vmtoolsd, etc.)\n    ↓\nGetty (Login Prompt)\n    ↓\nUser Shell (Bash)\n```\n\n### File System Structure\n```\n/ (root)                          - @ subvolume on /dev/sda3\n├── boot/\n│   ├── efi/                      - /dev/sda1 (FAT32, EFI partition)\n│   │   └── EFI/GRUB/\n│   ├── vmlinuz-linux             - Kernel\n│   └── initramfs-linux.img       - Initial RAM disk\n├── home/                         - @home subvolume on /dev/sda3\n│   └── myusername/\n├── var/\n│   └── cache/pacman/pkg/         - @pkg subvolume on /dev/sda3\n├── etc/                          - System configuration\n│   ├── fstab                     - Mount points\n│   ├── hostname                  - System name\n│   ├── locale.conf               - System language\n│   ├── vconsole.conf             - Console keymap\n│   └── sudoers                   - Sudo configuration\n└── usr/                          - Installed software\n    ├── bin/                      - Executables\n    └── lib/                      - Libraries\n```\n\n### Btrfs Subvolume Layout\n```\n/dev/sda3 (Btrfs filesystem \"ArchRoot\")\n├── @ subvolume        → mounted at /\n├── @home subvolume    → mounted at /home\n└── @pkg subvolume     → mounted at /var/cache/pacman/pkg\n```\n\n**Benefits of this layout:**\n\n- Snapshot root without home\n- Separate package cache from snapshots\n- Independent rollback of system vs. data\n- Efficient space usage with compression\n\n### Key Configuration Files\n\n| File | Purpose | Key Settings |\n|------|---------|--------------|\n| `/etc/fstab` | Defines mount points for boot | UUID-based mounts, Btrfs subvolumes |\n| `/etc/hostname` | System name on network | Your chosen hostname |\n| `/etc/locale.conf` | System language | `LANG=en_US.UTF-8` |\n| `/etc/vconsole.conf` | Console keyboard layout | `KEYMAP=de-latin1` |\n| `/etc/locale.gen` | Available locales | Uncommented locales to generate |\n| `/etc/sudoers` | Sudo permissions | `%wheel ALL=(ALL:ALL) ALL` |\n| `/boot/grub/grub.cfg` | GRUB menu configuration | Auto-generated, defines boot entries |\n| `/etc/default/grub` | GRUB settings | Timeout, kernel parameters, themes |\n\n### Understanding Package Management\n\n**Pacman basics:**\n```{bash}\n#| eval: false\n# Update package database\nsudo pacman -Sy\n\n# Upgrade all packages\nsudo pacman -Syu\n\n# Install package\nsudo pacman -S package_name\n\n# Remove package\nsudo pacman -R package_name\n\n# Search for package\npacman -Ss search_term\n\n# Query installed packages\npacman -Q\n\n# Get package info\npacman -Qi package_name\n\n# Clean package cache\nsudo pacman -Sc\n```\n\n**Package repositories:**\n\n- **core**: Essential packages\n- **extra**: Additional official packages\n- **multilib**: 32-bit support (optional)\n- **AUR**: Community-maintained (requires helper like `yay`)\n\n## Next Steps: Building Your Desktop Environment\n\nYour minimal system is a foundation. Here's the typical path forward:\n\n### 1. Install Display Server\n\n**Xorg (most compatible):**\n```{bash}\n#| eval: false\nsudo pacman -S xorg-server xorg-xinit\n```\n\n**Or Wayland (modern):**\n```{bash}\n#| eval: false\nsudo pacman -S wayland\n```\n\n### 2. Install Window Manager or Desktop Environment\n\n**Minimal (Window Manager):**\n```{bash}\n#| eval: false\n# i3 (tiling window manager)\nsudo pacman -S i3-wm i3status i3lock dmenu\n\n# Or Sway (i3 for Wayland)\nsudo pacman -S sway swaylock swayidle\n```\n\n**Full Desktop (Desktop Environment):**\n```{bash}\n#| eval: false\n# GNOME\nsudo pacman -S gnome gnome-extra\n\n# KDE Plasma\nsudo pacman -S plasma kde-applications\n\n# Xfce (lightweight)\nsudo pacman -S xfce4 xfce4-goodies\n```\n\n### 3. Install Essential Applications\n```{bash}\n#| eval: false\n# Terminal emulator\nsudo pacman -S alacritty  # or kitty, st\n\n# Web browser\nsudo pacman -S firefox\n\n# File manager\nsudo pacman -S thunar  # or nautilus, dolphin\n\n# Text editor\nsudo pacman -S neovim  # or gedit, kate\n\n# Development tools\nsudo pacman -S base-devel git\n```\n\n### 4. Display Manager (Login Screen)\n#| eval: false\n# LightDM (lightweight)\nsudo pacman -S lightdm lightdm-gtk-greeter\nsudo systemctl enable lightdm\n\n# Or SDDM (for KDE)\nsudo pacman -S sddm\nsudo systemctl enable sddm\n\n# Or GDM (for GNOME)\nsudo pacman -S gdm\nsudo systemctl enable gdm\n\n",
    "supporting": [
      "minimal_install_intro_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}